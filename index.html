<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maintenance Division Estimating Calculator</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-primary: #0a0f1a;
            --bg-secondary: #111827;
            --bg-tertiary: #1a2332;
            --bg-input: #0d1320;
            --border-color: #2a3548;
            --border-highlight: #3b4d6b;
            --text-primary: #e8edf5;
            --text-secondary: #9ca8bc;
            --text-muted: #6b7a94;
            --accent-red: #ef5350;
            --accent-red-dim: #c62828;
            --accent-yellow: #fdd835;
            --accent-yellow-dim: #f9a825;
            --accent-purple: #ab47bc;
            --accent-purple-dim: #7b1fa2;
            --accent-pink: #f06292;
            --accent-pink-dim: #c2185b;
            --accent-blue: #42a5f5;
            --accent-blue-dim: #1565c0;
            --accent-green: #66bb6a;
            --accent-green-dim: #2e7d32;
            --accent-orange: #ffa726;
            --accent-cyan: #26c6da;
            --accent-teal: #26a69a;
        }
        * { margin:0; padding:0; box-sizing:border-box; }
        body {
            font-family: 'IBM Plex Sans', -apple-system, BlinkMacSystemFont, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            min-height: 100vh;
            line-height: 1.5;
        }
        .container { max-width: 1400px; margin: 0 auto; padding: 1.5rem; }
        .header {
            display: flex; justify-content: space-between; align-items: center;
            flex-wrap: wrap; gap: 1rem; margin-bottom: 1.5rem;
            padding-bottom: 1rem; border-bottom: 1px solid var(--border-color);
        }
        .logo { display: flex; align-items: center; gap: 0.75rem; }
        .logo-icon {
            width: 42px; height: 42px;
            background: linear-gradient(135deg, var(--accent-orange), var(--accent-yellow));
            border-radius: 8px; display: flex; align-items: center; justify-content: center;
            font-weight: 700; font-size: 1.3rem; color: var(--bg-primary);
        }
        .logo-text h1 { font-size: 1.2rem; font-weight: 700; letter-spacing: -0.025em; }
        .logo-text span { font-size: 0.72rem; color: var(--text-muted); font-family: 'JetBrains Mono', monospace; }
        .header-controls { display: flex; gap: 0.6rem; align-items: center; flex-wrap: wrap; }
        .btn {
            padding: 0.5rem 1rem; border: none; border-radius: 6px; cursor: pointer;
            font-weight: 600; font-size: 0.85rem; transition: all 0.2s ease;
            font-family: inherit; display: inline-flex; align-items: center; gap: 0.4rem;
        }
        .btn-primary { background: linear-gradient(135deg, var(--accent-blue), var(--accent-blue-dim)); color: white; box-shadow: 0 2px 8px rgba(66,165,245,0.3); }
        .btn-primary:hover { transform: translateY(-1px); box-shadow: 0 4px 12px rgba(66,165,245,0.4); }
        .btn-success { background: linear-gradient(135deg, var(--accent-green), var(--accent-green-dim)); color: white; }
        .btn-danger { background: linear-gradient(135deg, var(--accent-red), var(--accent-red-dim)); color: white; }
        .btn-secondary { background: var(--bg-tertiary); color: var(--text-primary); border: 1px solid var(--border-color); }
        .btn-secondary:hover { background: var(--border-color); }
        .btn-small { padding: 0.35rem 0.75rem; font-size: 0.75rem; }
        .project-info {
            background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 1rem; margin-bottom: 1rem;
            display: flex; align-items: center; gap: 1rem; flex-wrap: wrap;
        }
        .project-info label { font-size: 0.75rem; font-weight: 600; color: var(--text-secondary); text-transform: uppercase; letter-spacing: 0.05em; }
        .project-info input {
            flex: 1; min-width: 250px; padding: 0.5rem 0.75rem;
            border: 1px solid var(--border-color); border-radius: 4px;
            background: var(--bg-input); color: var(--text-primary); font-size: 1rem; font-weight: 600;
        }
        .project-info input:focus { outline: none; border-color: var(--accent-orange); }
        .settings-panel {
            background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 1rem; margin-bottom: 1rem;
        }
        .settings-row { display: flex; flex-wrap: wrap; gap: 1.5rem; align-items: flex-end; }
        .setting-group { display: flex; flex-direction: column; gap: 0.35rem; }
        .setting-group label {
            font-size: 0.72rem; font-weight: 600; color: var(--text-secondary);
            text-transform: uppercase; letter-spacing: 0.05em;
        }
        .setting-group input, .setting-group select {
            padding: 0.5rem 0.75rem; border: 1px solid var(--border-color);
            border-radius: 4px; background: var(--bg-input); color: var(--text-primary);
            font-size: 0.85rem; min-width: 110px; font-family: 'JetBrains Mono', monospace;
        }
        .setting-group input:focus, .setting-group select:focus { outline: none; border-color: var(--accent-blue); }
        .panel-wrapper { margin-bottom: 0.75rem; }
        .panel-toggle {
            width: 100%; background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 0.65rem 1rem; cursor: pointer;
            display: flex; justify-content: space-between; align-items: center;
            color: var(--text-primary); font-weight: 600; font-size: 0.85rem;
            transition: all 0.2s ease; font-family: inherit;
        }
        .panel-toggle:hover { background: var(--bg-tertiary); }
        .panel-toggle .arrow { transition: transform 0.3s ease; font-size: 1rem; }
        .panel-toggle.open { border-radius: 8px 8px 0 0; }
        .panel-toggle.open .arrow { transform: rotate(180deg); }
        .panel-toggle .toggle-left { display: flex; align-items: center; gap: 0.75rem; }
        .panel-toggle .toggle-left input[type="checkbox"] { width: 16px; height: 16px; accent-color: var(--accent-orange); }
        .panel-content {
            display: none; background: var(--bg-secondary); border: 1px solid var(--border-color);
            border-top: none; border-radius: 0 0 8px 8px; padding: 1.25rem;
        }
        .panel-content.open { display: block; }
        .panel-toggle.disabled-look { opacity: 0.5; }
        .wt-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 1rem; }
        .wt-grid-wide { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1rem; }
        .input-group { margin-bottom: 0.65rem; }
        .input-group:last-child { margin-bottom: 0; }
        .input-group label {
            display: block; font-size: 0.7rem; font-weight: 600; color: var(--text-secondary);
            margin-bottom: 0.2rem; text-transform: uppercase;
        }
        .input-group .hint { font-size: 0.6rem; color: var(--text-muted); margin-bottom: 0.2rem; font-style: italic; text-transform: none; }
        .input-group input, .input-group select {
            width: 100%; padding: 0.45rem 0.6rem; border: 1px solid var(--border-color);
            border-radius: 4px; background: var(--bg-input); color: var(--text-primary);
            font-size: 0.8rem; font-family: 'JetBrains Mono', monospace;
        }
        .input-group input:focus, .input-group select:focus { outline: none; border-color: var(--accent-blue); box-shadow: 0 0 0 2px rgba(66,165,245,0.15); }
        .input-group input::placeholder { color: var(--text-muted); }
        .output-section {
            background: var(--bg-primary); border: 1px solid var(--border-color);
            border-radius: 6px; padding: 0.75rem; margin-top: 1rem;
        }
        .output-section h5 {
            font-size: 0.7rem; font-weight: 700; text-transform: uppercase; letter-spacing: 0.05em;
            color: var(--accent-cyan); margin-bottom: 0.5rem; padding-bottom: 0.35rem;
            border-bottom: 1px solid var(--border-color);
        }
        .output-row { display: flex; justify-content: space-between; align-items: center; padding: 0.15rem 0; font-size: 0.75rem; }
        .output-row .lbl { color: var(--text-secondary); }
        .output-row .val { font-family: 'JetBrains Mono', monospace; font-weight: 600; color: var(--text-primary); }
        .output-row.highlight .val { color: var(--accent-cyan); }
        .output-row.cost .val { color: var(--accent-green); }
        .output-divider { border-top: 1px dashed var(--border-color); margin: 0.3rem 0; }

        /* Three-Tier Output Table */
        .tier-table { width: 100%; border-collapse: collapse; font-size: 0.72rem; margin-top: 0.5rem; }
        .tier-table th {
            text-align: center; padding: 0.35rem 0.4rem; font-size: 0.62rem;
            text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted);
            border-bottom: 1px solid var(--border-color); font-weight: 600;
        }
        .tier-table th:first-child { text-align: left; }
        .tier-table td { padding: 0.35rem 0.4rem; text-align: center; font-family: 'JetBrains Mono', monospace; font-weight: 500; border-bottom: 1px solid var(--border-color); }
        .tier-table td:first-child { text-align: left; font-family: 'IBM Plex Sans', sans-serif; font-weight: 600; }
        .tier-table .tier-cons td:first-child { color: var(--accent-orange); }
        .tier-table .tier-std td:first-child { color: var(--accent-cyan); }
        .tier-table .tier-agg td:first-child { color: var(--accent-green); }
        .tier-table .tier-std { background: rgba(38, 198, 218, 0.06); }

        /* Striping Table */
        .stripe-table { width: 100%; border-collapse: collapse; font-size: 0.78rem; margin-top: 0.5rem; }
        .stripe-table th {
            text-align: left; padding: 0.4rem 0.5rem; font-size: 0.65rem;
            text-transform: uppercase; letter-spacing: 0.05em; color: var(--text-muted);
            border-bottom: 1px solid var(--border-color); font-weight: 600;
        }
        .stripe-table td { padding: 0.35rem 0.5rem; border-bottom: 1px solid var(--border-color); }
        .stripe-table input {
            width: 80px; padding: 0.3rem 0.5rem; border: 1px solid var(--border-color);
            border-radius: 4px; background: var(--bg-input); color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; text-align: right;
        }
        .stripe-table input:focus { outline: none; border-color: var(--accent-blue); }
        .stripe-table .unit { color: var(--text-muted); font-size: 0.7rem; }
        .stripe-table .calc-val { font-family: 'JetBrains Mono', monospace; color: var(--text-primary); font-weight: 600; }
        .stripe-table .machine-row { border-left: 3px solid var(--accent-blue); }
        .stripe-table .hand-row { border-left: 3px solid var(--accent-yellow); }

        /* Cost Summary */
        .cost-summary {
            background: var(--bg-secondary); border: 2px solid var(--accent-green);
            border-radius: 12px; padding: 1.5rem; margin-top: 1.5rem;
        }
        .cost-summary h2 {
            font-size: 1.1rem; font-weight: 700; color: var(--accent-green);
            text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color);
        }
        .cost-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 1.25rem; }
        .cost-category {
            background: var(--bg-primary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 1rem;
        }
        .cost-category h4 {
            font-size: 0.78rem; font-weight: 700; color: var(--accent-cyan);
            text-transform: uppercase; margin-bottom: 0.6rem;
            padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color);
        }
        .cost-line { display: flex; justify-content: space-between; align-items: center; padding: 0.25rem 0; font-size: 0.78rem; }
        .cost-line .lbl { color: var(--text-secondary); }
        .cost-line .val { font-family: 'JetBrains Mono', monospace; font-weight: 600; color: var(--text-primary); }
        .cost-line.subtotal { border-top: 1px solid var(--border-color); margin-top: 0.4rem; padding-top: 0.4rem; }
        .cost-line.subtotal .lbl, .cost-line.subtotal .val { font-weight: 700; color: var(--accent-cyan); }
        .cost-totals { margin-top: 1.25rem; padding-top: 1rem; border-top: 2px solid var(--border-color); }
        .cost-total-row { display: flex; justify-content: space-between; align-items: center; padding: 0.5rem 0; }
        .cost-total-row .lbl { font-size: 0.9rem; font-weight: 600; color: var(--text-secondary); }
        .cost-total-row .val { font-family: 'JetBrains Mono', monospace; font-size: 1.1rem; font-weight: 700; color: var(--text-primary); }
        .cost-total-row.grand {
            background: var(--bg-tertiary); margin: 0.5rem -1rem; padding: 0.75rem 1rem; border-radius: 6px;
        }
        .cost-total-row.grand .lbl { color: var(--accent-green); font-size: 1rem; }
        .cost-total-row.grand .val { font-size: 1.4rem; color: var(--accent-green); }
        .markup-row { display: flex; align-items: center; gap: 1rem; padding: 0.5rem 0; }
        .markup-row label { font-size: 0.85rem; color: var(--text-secondary); }
        .markup-row input {
            width: 80px; padding: 0.4rem 0.5rem; border: 1px solid var(--border-color);
            border-radius: 4px; background: var(--bg-input); color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace; font-size: 0.9rem; text-align: right;
        }
        .markup-row input:focus { outline: none; border-color: var(--accent-green); }

        /* HeavyBid Summary */
        .hb-summary {
            background: var(--bg-secondary); border: 2px solid var(--accent-cyan);
            border-radius: 12px; padding: 1.5rem; margin-top: 1.5rem;
        }
        .hb-summary h2 {
            font-size: 1.1rem; font-weight: 700; color: var(--accent-cyan);
            text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 1rem; padding-bottom: 0.75rem; border-bottom: 1px solid var(--border-color);
        }
        .hb-table { width: 100%; border-collapse: collapse; font-size: 0.8rem; }
        .hb-table th {
            text-align: left; padding: 0.5rem 0.6rem; font-size: 0.68rem;
            text-transform: uppercase; letter-spacing: 0.04em; color: var(--text-muted);
            border-bottom: 2px solid var(--border-color); font-weight: 600;
        }
        .hb-table th:not(:first-child) { text-align: center; }
        .hb-table td { padding: 0.45rem 0.6rem; border-bottom: 1px solid var(--border-color); font-family: 'JetBrains Mono', monospace; }
        .hb-table td:first-child { font-family: 'IBM Plex Sans', sans-serif; font-weight: 600; color: var(--text-primary); }
        .hb-table td:not(:first-child) { text-align: center; }
        .hb-table .hb-cons { color: var(--accent-orange); }
        .hb-table .hb-std { color: var(--accent-cyan); font-weight: 700; }
        .hb-table .hb-agg { color: var(--accent-green); }

        /* Rate Config Panel */
        .rate-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(280px, 1fr)); gap: 1.25rem; }
        .rate-section {
            background: var(--bg-primary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 1rem;
        }
        .rate-section h4 {
            font-size: 0.78rem; font-weight: 700; color: var(--accent-cyan);
            text-transform: uppercase; letter-spacing: 0.05em;
            margin-bottom: 0.6rem; padding-bottom: 0.4rem; border-bottom: 1px solid var(--border-color);
        }
        .rate-row { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.4rem; }
        .rate-row:last-child { margin-bottom: 0; }
        .rate-row label { font-size: 0.78rem; color: var(--text-secondary); }
        .rate-row input {
            width: 100px; padding: 0.35rem 0.5rem; border: 1px solid var(--border-color);
            border-radius: 4px; background: var(--bg-input); color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace; font-size: 0.78rem; text-align: right;
        }
        .rate-row input:focus { outline: none; border-color: var(--accent-cyan); }
        .rate-actions { display: flex; gap: 0.5rem; margin-top: 1rem; padding-top: 1rem; border-top: 1px solid var(--border-color); justify-content: flex-end; }
        .tag { display: inline-block; width: 10px; height: 10px; border-radius: 2px; margin-right: 4px; }
        .tag-red { background: var(--accent-red); }
        .tag-purple { background: var(--accent-purple); }
        .tag-yellow { background: var(--accent-yellow); }
        .tag-pink { background: var(--accent-pink); }
        .tag-blue { background: var(--accent-blue); }
        .tag-green { background: var(--accent-green); }
        .tag-teal { background: var(--accent-teal); }
        .tag-orange { background: var(--accent-orange); }
        .tag-cyan { background: var(--accent-cyan); }
        .toast {
            position: fixed; bottom: 2rem; right: 2rem; background: var(--accent-green);
            color: white; padding: 1rem 1.5rem; border-radius: 8px; font-weight: 600;
            box-shadow: 0 4px 20px rgba(0,0,0,0.3); transform: translateY(100px);
            opacity: 0; transition: all 0.3s ease; z-index: 1000;
        }
        .toast.show { transform: translateY(0); opacity: 1; }
        .footer {
            margin-top: 2rem; padding-top: 1rem; border-top: 1px solid var(--border-color);
            text-align: center; font-size: 0.72rem; color: var(--text-muted);
        }
        .phase-input {
            width: 60px !important; display: inline-block;
        }
        .note { font-size: 0.7rem; color: var(--text-muted); margin-top: 0.5rem; font-style: italic; }
        .analysis-card {
            background: var(--bg-primary); border: 1px solid var(--border-color);
            border-radius: 8px; padding: 1rem; margin-bottom: 0.75rem; border-left: 3px solid var(--accent-orange);
        }
        .analysis-card.flag-low { border-left-color: var(--accent-blue); }
        .analysis-card.flag-very-high, .analysis-card.flag-very-low { border-left-color: var(--accent-red); }
        .analysis-card.flag-info { border-left-color: var(--accent-cyan); }
        .analysis-card.flag-ok { border-left-color: var(--accent-green); }
        .analysis-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 0.5rem; }
        .analysis-header .activity-name { font-weight: 700; font-size: 0.85rem; }
        .analysis-badge {
            display: inline-block; padding: 0.15rem 0.5rem; border-radius: 4px;
            font-size: 0.65rem; font-weight: 700; letter-spacing: 0.05em;
        }
        .analysis-badge.high { background: rgba(255,167,38,0.15); color: var(--accent-orange); }
        .analysis-badge.low { background: rgba(66,165,245,0.15); color: var(--accent-blue); }
        .analysis-badge.very-high, .analysis-badge.very-low { background: rgba(239,83,80,0.15); color: var(--accent-red); }
        .analysis-badge.info { background: rgba(38,198,218,0.15); color: var(--accent-cyan); }
        .analysis-badge.ok { background: rgba(102,187,106,0.15); color: var(--accent-green); }
        .analysis-benchmark { font-size: 0.72rem; color: var(--text-muted); margin-bottom: 0.4rem; font-family: 'JetBrains Mono', monospace; }
        .analysis-reasons { list-style: none; padding: 0; }
        .analysis-reasons li {
            font-size: 0.75rem; color: var(--text-secondary); padding: 0.2rem 0 0.2rem 1rem;
            position: relative;
        }
        .analysis-reasons li::before { content: ''; position: absolute; left: 0; top: 0.55rem; width: 6px; height: 6px; border-radius: 50%; background: var(--text-muted); }
        @media (max-width: 768px) {
            .wt-grid, .wt-grid-wide, .rate-grid, .cost-grid { grid-template-columns: 1fr; }
            .settings-row { flex-direction: column; gap: 0.75rem; }
            .header { flex-direction: column; align-items: flex-start; }
        }

        /* Reviewer Notes */
        .notes-box {
            width: 100%;
            min-height: 60px;
            padding: 0.6rem 0.75rem;
            margin-top: 0.75rem;
            border: 1px dashed var(--border-color);
            border-radius: 6px;
            background: var(--bg-input);
            color: var(--text-secondary);
            font-family: 'IBM Plex Sans', sans-serif;
            font-size: 0.78rem;
            line-height: 1.5;
            resize: vertical;
            transition: border-color 0.2s ease;
        }
        .notes-box:focus {
            outline: none;
            border-color: var(--accent-yellow);
            border-style: solid;
            box-shadow: 0 0 0 2px rgba(253, 216, 53, 0.12);
            color: var(--text-primary);
        }
        .notes-box::placeholder {
            color: var(--text-muted);
            font-style: italic;
        }

        /* Hover Tooltips */
        .tip {
            position: relative;
            cursor: help;
            border-bottom: 1px dotted var(--text-muted);
        }
        .tip::after {
            content: attr(data-tip);
            position: absolute;
            bottom: calc(100% + 8px);
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-tertiary);
            color: var(--text-primary);
            border: 1px solid var(--border-highlight);
            border-radius: 6px;
            padding: 0.5rem 0.75rem;
            font-size: 0.7rem;
            font-weight: 400;
            line-height: 1.5;
            white-space: pre-line;
            max-width: 320px;
            min-width: 200px;
            z-index: 100;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s ease;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.3);
            text-transform: none;
            letter-spacing: normal;
            font-family: 'IBM Plex Sans', sans-serif;
        }
        .tip:hover::after {
            opacity: 1;
        }
        /* === Scope Exclusions & Assumptions === */
        .scope-section-header {
            font-size: 0.72rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin: 0.75rem 0 0.4rem 0;
            padding-bottom: 0.25rem;
            border-bottom: 1px solid var(--border-primary);
        }
        .scope-section-header.incl { color: var(--accent-green); }
        .scope-section-header.excl { color: var(--accent-orange); }
        .scope-item {
            display: grid;
            grid-template-columns: 1fr auto auto;
            gap: 0.5rem;
            align-items: center;
            padding: 0.35rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            font-size: 0.78rem;
        }
        .scope-item-name {
            color: var(--text-primary);
            font-weight: 500;
        }
        .scope-radio-group {
            display: flex;
            gap: 0.15rem;
        }
        .scope-radio-group label {
            font-size: 0.68rem;
            padding: 0.15rem 0.45rem;
            border-radius: 4px;
            cursor: pointer;
            border: 1px solid var(--border-primary);
            color: var(--text-muted);
            transition: all 0.15s ease;
        }
        .scope-radio-group input { display: none; }
        .scope-radio-group input:checked + label.lbl-incl {
            background: rgba(0,204,102,0.15);
            border-color: var(--accent-green);
            color: var(--accent-green);
            font-weight: 600;
        }
        .scope-radio-group input:checked + label.lbl-excl {
            background: rgba(255,136,0,0.15);
            border-color: var(--accent-orange);
            color: var(--accent-orange);
            font-weight: 600;
        }
        .scope-radio-group input:checked + label.lbl-na {
            background: rgba(255,255,255,0.06);
            border-color: var(--text-muted);
            color: var(--text-muted);
            font-weight: 600;
        }
        .scope-item-note {
            grid-column: 1 / -1;
            margin-top: -0.15rem;
        }
        .scope-item-note input {
            width: 100%;
            background: var(--bg-tertiary);
            border: 1px solid var(--border-primary);
            border-radius: 4px;
            color: var(--text-primary);
            padding: 0.25rem 0.5rem;
            font-size: 0.72rem;
            font-family: inherit;
        }
        .scope-item-note input::placeholder { color: var(--text-muted); opacity: 0.6; }
        /* === Calendar Duration === */
        .timeline-row {
            display: grid;
            grid-template-columns: 70px 1fr 60px 60px;
            gap: 0.5rem;
            align-items: center;
            padding: 0.35rem 0.5rem;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            font-size: 0.78rem;
        }
        .timeline-row.header-row {
            font-weight: 700;
            color: var(--text-muted);
            font-size: 0.7rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            border-bottom: 1px solid var(--border-primary);
        }
        .timeline-row.cure-row {
            background: rgba(255,170,0,0.06);
            border-left: 3px solid #ffaa00;
            font-style: italic;
            color: var(--text-muted);
        }
        .timeline-row .day-range {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            color: var(--accent-cyan);
        }
        .timeline-row .activity-name { color: var(--text-primary); }
        .timeline-row .crew-col { text-align: center; color: var(--text-secondary); }
        .timeline-row .hours-col {
            text-align: right;
            font-family: 'JetBrains Mono', monospace;
            color: var(--text-secondary);
        }
        .timeline-total {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.6rem 0.75rem;
            margin-top: 0.5rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-highlight);
            font-size: 0.82rem;
            font-weight: 700;
        }
        /* === Unit Cost Column === */
        .unit-cost-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.2rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
            font-size: 0.78rem;
        }
        .unit-cost-row .lbl { color: var(--text-secondary); flex: 1; }
        .unit-cost-row .val {
            font-family: 'JetBrains Mono', monospace;
            font-weight: 600;
            margin-right: 0.4rem;
        }
        .unit-cost-badge {
            font-size: 0.62rem;
            font-weight: 700;
            padding: 0.1rem 0.35rem;
            border-radius: 3px;
            letter-spacing: 0.3px;
            white-space: nowrap;
        }
        .unit-cost-badge.in-range  { background: rgba(0,204,102,0.15); color: #00cc66; }
        .unit-cost-badge.high      { background: rgba(255,170,0,0.15); color: #ffaa00; }
        .unit-cost-badge.low       { background: rgba(255,170,0,0.15); color: #ffaa00; }
        .unit-cost-badge.very-high { background: rgba(255,68,68,0.15); color: #ff4444; }
        .unit-cost-badge.very-low  { background: rgba(255,68,68,0.15); color: #ff4444; }
        /* === Confidence Score === */
        .confidence-section { margin-bottom: 0.75rem; }
        .confidence-bar-row {
            display: grid;
            grid-template-columns: 160px 1fr 50px;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.4rem;
            font-size: 0.78rem;
        }
        .confidence-bar-row .label { color: var(--text-secondary); font-weight: 500; }
        .confidence-bar-track {
            height: 14px;
            background: var(--bg-tertiary);
            border-radius: 7px;
            overflow: hidden;
            position: relative;
        }
        .confidence-bar-fill {
            height: 100%;
            border-radius: 7px;
            transition: width 0.4s ease;
        }
        .confidence-bar-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            font-weight: 700;
            text-align: right;
        }
        .confidence-composite {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-top: 0.75rem;
            padding: 0.6rem 0.75rem;
            background: var(--bg-tertiary);
            border-radius: 8px;
            border: 1px solid var(--border-highlight);
        }
        .confidence-composite .score {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            font-weight: 800;
        }
        .confidence-composite .descriptor {
            font-size: 0.8rem;
            font-weight: 600;
        }
        .confidence-composite .detail {
            font-size: 0.7rem;
            color: var(--text-muted);
        }
        .confidence-explain {
            grid-column: 1 / -1;
            font-size: 0.7rem;
            color: var(--text-muted);
            line-height: 1.45;
            padding: 0.2rem 0 0.5rem 0;
            border-bottom: 1px solid rgba(255,255,255,0.04);
        }
        .confidence-explain .driver {
            display: flex;
            gap: 0.4rem;
            padding: 0.1rem 0;
        }
        .confidence-explain .driver-tag {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            font-weight: 600;
            white-space: nowrap;
        }
        .confidence-explain .driver-tag.good { color: var(--accent-green); }
        .confidence-explain .driver-tag.mid  { color: var(--accent-cyan); }
        .confidence-explain .driver-tag.warn { color: #ffaa00; }
        .confidence-explain .driver-tag.low  { color: #ff4444; }
        .confidence-explain .definition {
            font-style: italic;
            color: var(--text-muted);
            opacity: 0.85;
            margin-bottom: 0.3rem;
        }
    </style>
</head>
<body>
<div class="container">

<!-- Header -->
<header class="header">
    <div class="logo">
        <div class="logo-icon">M</div>
        <div class="logo-text">
            <h1>Maintenance Division Estimating Calculator</h1>
            <span>v4.1 | Field-Calibrated | Three-Tier Output | Crew Clustering | Crew Size Adjustment | Estimate Confidence</span>
        </div>
    </div>
    <div class="header-controls">
        <button class="btn btn-primary" onclick="calculateAll()"><span>‚ö°</span> Calculate</button>
        <button class="btn btn-secondary" onclick="exportResults()"><span>üìã</span> Quick Export</button>
        <button class="btn btn-secondary" onclick="exportComprehensiveText()"><span>üìÑ</span> Full Export</button>
        <button class="btn btn-secondary" onclick="exportJSON()"><span>üíæ</span> JSON</button>
        <button class="btn btn-secondary" onclick="printEstimate()"><span>üñ®Ô∏è</span> Print</button>
        <button class="btn btn-danger" onclick="resetForm()"><span>‚Ü∫</span> Reset</button>
    </div>
</header>

<!-- Project Info -->
<div class="project-info">
    <label>Project</label>
    <input type="text" id="projectName" placeholder="Enter project name...">
</div>

<!-- Global Settings -->
<div class="settings-panel">
    <div class="settings-row">
        <div class="setting-group">
            <label><span class="tip" data-tip="Base shift length for production hours. 8h is standard. Determines shift increment snapping.">Standard Shift</span></label>
            <select id="hoursPerDay" onchange="calculateAll()">
                <option value="6">6 hours</option>
                <option value="8" selected>8 hours</option>
                <option value="10">10 hours</option>
            </select>
        </div>
        <div class="setting-group">
            <label><span class="tip" data-tip="Maximum allowed shift length including overtime. Used when production exceeds standard shift.">Max Shift</span></label>
            <select id="maxShift" onchange="calculateAll()">
                <option value="8">8 hours</option>
                <option value="10" selected>10 hours</option>
                <option value="12">12 hours</option>
            </select>
        </div>
        <div class="setting-group">
            <label>9.5mm Asphalt ($/ton)</label>
            <input type="number" id="asphaltPrice" placeholder="0.00" step="0.01" value="" oninput="calculateAll()">
        </div>
        <div class="setting-group">
            <label>19mm Base Asphalt ($/ton)</label>
            <input type="number" id="baseAsphaltPrice" placeholder="0.00" step="0.01" value="" oninput="calculateAll()">
        </div>
        <div class="setting-group">
            <label>DGA ($/ton)</label>
            <input type="number" id="dgaPrice" placeholder="0.00" step="0.01" value="" oninput="calculateAll()">
        </div>
        <div class="setting-group">
            <label><span class="tip" data-tip="Applied to direct cost (labor + material) to calculate bid price.">Markup %</span></label>
            <input type="number" id="markupPercent" value="60" step="1" oninput="calculateAll()">
        </div>
        <div class="setting-group">
            <label><span class="tip" data-tip="ON groups co-deployed activities sharing equipment into one mobilization. OFF calculates each activity standalone.">Crew Clustering</span></label>
            <select id="clusterMode" onchange="calculateAll()">
                <option value="off">Off (standalone per activity)</option>
                <option value="on" selected>On (shared mobilization)</option>
            </select>
        </div>
    </div>
</div>

<!-- Rate Configuration -->
<div class="panel-wrapper">
    <button class="panel-toggle" onclick="togglePanel(this,'rateContent')">
        <span>üí∞ Crew Rates, Material Costs & Production Rates (Click to Expand)</span>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="rateContent">
        <div class="rate-grid">
            <div class="rate-section">
                <h4><span class="tip" data-tip="All-in hourly cost including labor, equipment, and vehicle.">Crew Hourly Rates (Equip + Labor)</span></h4>
                <div class="rate-row" style="border-bottom:1px solid var(--border-color); padding-bottom:0.4rem; margin-bottom:0.4rem;">
                    <label><span class="tip" data-tip="Loaded hourly rate for each additional laborer above base crew size (AAS Paint Labor: $26.30 base + 14.19% tax + $8.99 fringe = $39.03). Used to adjust crew rates when crew size differs from the calibrated default.">Laborer Adjustment Rate</span></label>
                    <input type="number" id="rateLaborerAdj" value="39.03" step="0.01">
                </div>
                <div class="rate-row"><label>Crack Fill Crew</label><input type="number" id="rateCrackFill" value="219.34" step="0.01"></div>
                <div class="rate-row"><label>Sealcoat Crew</label><input type="number" id="rateSealcoat" value="245.79" step="0.01"></div>
                <div class="rate-row"><label>Striping Crew</label><input type="number" id="rateStriping" value="245.75" step="0.01"></div>
                <div class="rate-row"><label>Asphalt Repair (‚â§4T)</label><input type="number" id="rateAsphaltSmall" value="351.35" step="0.01"></div>
                <div class="rate-row"><label>Asphalt Repair (>4T)</label><input type="number" id="rateAsphaltLarge" value="555.10" step="0.01"></div>
                <div class="rate-row"><label>Wheel Stop Install</label><input type="number" id="rateWsInstall" value="261.99" step="0.01"></div>
                <div class="rate-row"><label>Wheel Stop Reset</label><input type="number" id="rateWsReset" value="133.40" step="0.01"></div>
                <div class="rate-row"><label>Wheel Stop Removal</label><input type="number" id="rateWsRemove" value="179.94" step="0.01"></div>
                <div class="rate-row"><label>Rubber Speed Bump</label><input type="number" id="rateSpeedBump" value="269.27" step="0.01"></div>
                <div class="rate-row"><label>Bollard Crew</label><input type="number" id="rateBollard" value="360.73" step="0.01"></div>
                <div class="rate-row"><label>Sign Crew</label><input type="number" id="rateSign" value="360.73" step="0.01"></div>
                <div class="rate-row"><label>Mastic Crew (excl machine)</label><input type="number" id="rateMastic" value="310.02" step="0.01"></div>
                <div class="rate-row"><label>Inlet Crew</label><input type="number" id="rateInlet" value="297.07" step="0.01"></div>
                <div class="rate-row"><label>Speed Hump Crew</label><input type="number" id="rateSpeedHump" value="514.02" step="0.01"></div>
            </div>
            <div class="rate-section">
                <h4>Material Unit Costs</h4>
                <div class="rate-row"><label>Crack Fill ($/LF)</label><input type="number" id="matCrackFill" value="0.19" step="0.01"></div>
                <div class="rate-row"><label>Sealer ($/SF)</label><input type="number" id="matSealcoat" value="0.07" step="0.01"></div>
                <div class="rate-row"><label>4" Paint Lines ($/LF)</label><input type="number" id="mat4Line" value="0.10" step="0.01"></div>
                <div class="rate-row"><label>6" Paint Lines ($/LF)</label><input type="number" id="mat6Line" value="0.15" step="0.01"></div>
                <div class="rate-row"><label>12" Paint Lines ($/LF)</label><input type="number" id="mat12Line" value="0.30" step="0.01"></div>
                <div class="rate-row"><label>24" Paint Lines ($/LF)</label><input type="number" id="mat24Line" value="0.60" step="0.01"></div>
                <div class="rate-row"><label>Arrows ($/EA)</label><input type="number" id="matArrow" value="8.50" step="0.01"></div>
                <div class="rate-row"><label>HC Symbol w/ Hash ($/EA)</label><input type="number" id="matHC" value="12.50" step="0.01"></div>
                <div class="rate-row"><label>Stencils/Lettering ($/EA)</label><input type="number" id="matStencil" value="4.25" step="0.01"></div>
                <div class="rate-row"><label>Curb Paint ($/LF)</label><input type="number" id="matCurb" value="0.30" step="0.01"></div>
                <div class="rate-row"><label>Wheel Stop w/ Pins ($/UN)</label><input type="number" id="matWsNew" value="55.00" step="0.01"></div>
                <div class="rate-row"><label>WS Reset Pins ($/UN)</label><input type="number" id="matWsPin" value="4.00" step="0.01"></div>
                <div class="rate-row"><label>WS Disposal ($/UN)</label><input type="number" id="matWsDispose" value="16.67" step="0.01"></div>
                <div class="rate-row"><label>Rubber Speed Bump ($/UN)</label><input type="number" id="matSpeedBump" value="560.00" step="0.01"></div>
                <div class="rate-row"><label>Bollard ($/UN)</label><input type="number" id="matBollard" value="260.00" step="0.01"></div>
                <div class="rate-row"><label>Small Sign ($/UN)</label><input type="number" id="matSignSmall" value="110.00" step="0.01"></div>
                <div class="rate-row"><label>Large Sign ($/UN)</label><input type="number" id="matSignLarge" value="170.00" step="0.01"></div>
                <div class="rate-row"><label>Mastic Box 30lb ($/box incl tax)</label><input type="number" id="matMasticBox" value="31.99" step="0.01"></div>
                <div class="rate-row"><label>Mastic Machine ($/DAY incl tax)</label><input type="number" id="matMasticMachine" value="586.44" step="0.01"></div>
                <div class="rate-row"><label>Block & Mortar ($/UN)</label><input type="number" id="matBlock" value="150.00" step="0.01"></div>
                <div class="rate-row"><label>Casting ($/EA)</label><input type="number" id="matCasting" value="300.00" step="0.01"></div>
                <div class="rate-row"><label>Grinder Rental ($/DAY)</label><input type="number" id="matPaintRemoval" value="650.00" step="0.01"></div>
            </div>
            <div class="rate-section">
                <h4><span class="tip" data-tip="Units completed per standard shift day. Field-calibrated by Darrell Bishop.">Production Rates (per day, standard crew)</span></h4>
                <div class="rate-row"><label>Crack Fill (LF/day)</label><input type="number" id="prodCrackFill" value="4000"></div>
                <div class="rate-row"><label>Sealcoat (SF/day)</label><input type="number" id="prodSealcoat" value="52000"></div>
                <div class="rate-row"><label>4" Lines (LF/day)</label><input type="number" id="prod4Line" value="5000"></div>
                <div class="rate-row"><label>6" Lines (LF/day)</label><input type="number" id="prod6Line" value="5000"></div>
                <div class="rate-row"><label>12" Lines (LF/day)</label><input type="number" id="prod12Line" value="5000"></div>
                <div class="rate-row"><label>24" Lines (LF/day)</label><input type="number" id="prod24Bar" value="3000"></div>
                <div class="rate-row"><label>HC Symbols (EA/day)</label><input type="number" id="prodHC" value="80"></div>
                <div class="rate-row"><label>Arrows (EA/day)</label><input type="number" id="prodArrow" value="50"></div>
                <div class="rate-row"><label>Stencils/Lettering (EA/day)</label><input type="number" id="prodStencil" value="200"></div>
                <div class="rate-row"><label>Curbing (LF/day)</label><input type="number" id="prodCurb" value="5000"></div>
                <div class="rate-row"><label>Asphalt Repair (SF/day)</label><input type="number" id="prodAsphaltRepair" value="600"></div>
                <div class="rate-row"><label><span class="tip" data-tip="New install: drill, set, pin. Field-calibrated Q21.">WS Install (UN/day)</span></label><input type="number" id="prodWsInstall" value="80"></div>
                <div class="rate-row"><label><span class="tip" data-tip="Re-pin existing stop. ~2x faster than install (no drilling). Field Q21.">WS Reset (UN/day)</span></label><input type="number" id="prodWsReset" value="155"></div>
                <div class="rate-row"><label><span class="tip" data-tip="Remove & dispose. ~2.5-3x faster than install. Field Q21.">WS Removal (UN/day)</span></label><input type="number" id="prodWsRemoval" value="220"></div>
                <div class="rate-row"><label>Rubber Speed Bumps (UN/day)</label><input type="number" id="prodSpeedBump" value="16"></div>
                <div class="rate-row"><label>Bollards (UN/day)</label><input type="number" id="prodBollard" value="8"></div>
                <div class="rate-row"><label>Signs - Post (UN/day)</label><input type="number" id="prodSignPost" value="32"></div>
                <div class="rate-row"><label>Signs - Bollard (UN/day)</label><input type="number" id="prodSignBollard" value="8"></div>
                <div class="rate-row"><label>Mastic (LF/day)</label><input type="number" id="prodMastic" value="1000"></div>
                <div class="rate-row"><label>Inlet Repair (UN/day)</label><input type="number" id="prodInletRepair" value="6"></div>
                <div class="rate-row"><label>Inlet Reconstruct (hrs/unit)</label><input type="number" id="prodInletRecon" value="8"></div>
                <div class="rate-row"><label>Speed Humps (UN/day)</label><input type="number" id="prodSpeedHump" value="4"></div>
                <div class="rate-row"><label>Paint Removal (LF/day)</label><input type="number" id="prodPaintRemoval" value="2000"></div>
            </div>
            <div class="rate-section">
                <h4>Default Crew Sizes</h4>
                <div class="rate-row"><label>Crack Fill</label><input type="number" id="crewCrackFill" value="3" min="2" max="5"></div>
                <div class="rate-row"><label>Sealcoat</label><input type="number" id="crewSealcoat" value="4" min="2" max="8"></div>
                <div class="rate-row"><label>Striping</label><input type="number" id="crewStriping" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Asphalt Repair (‚â§4T)</label><input type="number" id="crewAsphaltSmall" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Asphalt Repair (>4T)</label><input type="number" id="crewAsphaltLarge" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Wheel Stop Install</label><input type="number" id="crewWsInstall" value="3" min="2" max="5"></div>
                <div class="rate-row"><label>Rubber Speed Bump</label><input type="number" id="crewSpeedBump" value="3" min="2" max="5"></div>
                <div class="rate-row"><label>Bollard</label><input type="number" id="crewBollard" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Sign</label><input type="number" id="crewSign" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Mastic</label><input type="number" id="crewMastic" value="4" min="2" max="6"></div>
                <div class="rate-row"><label>Inlet</label><input type="number" id="crewInlet" value="4" min="2" max="5"></div>
                <div class="rate-row"><label>Speed Hump</label><input type="number" id="crewSpeedHump" value="4" min="2" max="5"></div>
            </div>
            <div class="rate-section">
                <h4><span class="tip" data-tip="Extra material ordered beyond calculated qty. Accounts for spillage, overspray, and cut waste.">Material Waste Factors (%)</span></h4>
                <p style="font-size:0.65rem; color:var(--text-muted); margin-bottom:0.5rem;">Applied to material quantities before costing. Discrete items (wheel stops, signs, etc.) do not need waste.</p>
                <div class="rate-row"><label>Crack Fill</label><input type="number" id="wasteCrackFill" value="10" min="0" step="1"> %</div>
                <div class="rate-row"><label>Sealcoat</label><input type="number" id="wasteSealcoat" value="5" min="0" step="1"> %</div>
                <div class="rate-row"><label>Striping Paint</label><input type="number" id="wasteStriping" value="5" min="0" step="1"> %</div>
                <div class="rate-row"><label>Asphalt / DGA</label><input type="number" id="wasteAsphalt" value="7" min="0" step="1"> %</div>
                <div class="rate-row"><label>Mastic</label><input type="number" id="wasteMastic" value="10" min="0" step="1"> %</div>
                <div class="rate-row"><label>Speed Hump Asphalt</label><input type="number" id="wasteSpeedHump" value="5" min="0" step="1"> %</div>
            </div>
        </div>
        <div class="rate-actions">
            <button class="btn btn-success btn-small" onclick="saveRates()">üíæ Save Rates</button>
            <button class="btn btn-secondary btn-small" onclick="loadRates()">üìÇ Load Rates</button>
            <button class="btn btn-danger btn-small" onclick="clearSavedRates()">üóëÔ∏è Clear Saved</button>
        </div>
    </div>
</div>

<!-- ============================================ -->
<!-- WORK TYPE SECTIONS -->
<!-- ============================================ -->

<!-- 1. CRACK FILLING -->
<div class="panel-wrapper" id="wt_crackfill_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_crackfill')">
        <div class="toggle-left">
            <input type="checkbox" id="en_crackfill" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-orange"></span>Crack Filling<span class="cluster-badge" style="font-size:0.65rem; color:#ab47bc; margin-left:6px;">&#x1F7E3; Crack Fill</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_crackfill">
        <div class="wt-grid">
            <div class="input-group"><label>Linear Feet (LF)</label><input type="number" id="cf_lf" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="cf_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="cf_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <div class="output-section"><h5>Crack Filling Output</h5><div id="cf_output"></div></div>
        <textarea id="note_cf" class="notes-box" placeholder="Reviewer notes for Crack Filling..."></textarea>
    </div>
</div>

<!-- 2. SEALCOATING -->
<div class="panel-wrapper" id="wt_sealcoat_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_sealcoat')">
        <div class="toggle-left">
            <input type="checkbox" id="en_sealcoat" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-blue"></span>Seal Coating<span class="cluster-badge" style="font-size:0.65rem; color:#66bb6a; margin-left:6px;">&#x1F7E2; Sealcoat</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_sealcoat">
        <div class="wt-grid">
            <div class="input-group"><label>Square Feet (SF)</label><input type="number" id="sc_sf" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group">
                <label><span class="tip" data-tip="Application method drives production rate and base crew size. Spray Rig: spray bar + wand edge work (standard commercial). Wand Only: all hand-spray (tight lots, apartments). Dual Wand: two wand operators for schedule compression on larger jobs without rig.">Method</span></label>
                <select id="sc_method" onchange="applySealcoatMethod(); calculateAll()">
                    <option value="sprayRig" selected>Spray Rig + Wand</option>
                    <option value="wandOnly">Wand Only</option>
                    <option value="dualWand">Dual Wand</option>
                </select>
            </div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="sc_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="sc_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note" id="sc_methodNote">Spray Rig: 4-man crew (4th operates manual spray bar). 52K SF/day open lot, 42-45K complex. 2-coat at 100 SF/gal, 125 gal/hr sustained.</p>
        <div class="output-section"><h5>Sealcoating Output</h5><div id="sc_output"></div></div>
        <textarea id="note_sc" class="notes-box" placeholder="Reviewer notes for Sealcoating..."></textarea>
    </div>
</div>

<!-- 3. STRIPING -->
<div class="panel-wrapper" id="wt_striping_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_striping')">
        <div class="toggle-left">
            <input type="checkbox" id="en_striping" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-yellow"></span>Striping<span class="cluster-badge" style="font-size:0.65rem; color:#42a5f5; margin-left:6px;">&#x1F537; Paint</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_striping">
        <div class="wt-grid" style="margin-bottom:0.5rem;">
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="st_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="st_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="tip" data-tip="Machine and hand items run concurrently. Duration = max(machine, hand), not the sum." style="font-size:0.65rem; color:var(--text-muted); margin-bottom:0.5rem;">
            <span style="display:inline-block;width:10px;height:10px;background:var(--accent-blue);border-radius:2px;vertical-align:middle;margin-right:3px;"></span> Machine items
            <span style="display:inline-block;width:10px;height:10px;background:var(--accent-yellow);border-radius:2px;vertical-align:middle;margin-left:10px;margin-right:3px;"></span> Hand items (concurrent with machine)
        </p>
        <table class="stripe-table">
            <thead><tr><th>Item</th><th>Qty</th><th>Unit</th><th>Prod/Day</th><th>Hours</th><th>Mat Cost</th></tr></thead>
            <tbody>
                <tr class="machine-row"><td>4" Lines</td><td><input type="number" id="st_4line" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">LF</td><td class="calc-val" id="st_4line_prod">5,000</td><td class="calc-val" id="st_4line_hrs">0</td><td class="calc-val" id="st_4line_mat">$0</td></tr>
                <tr class="machine-row"><td>6" Lines</td><td><input type="number" id="st_6line" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">LF</td><td class="calc-val" id="st_6line_prod">5,000</td><td class="calc-val" id="st_6line_hrs">0</td><td class="calc-val" id="st_6line_mat">$0</td></tr>
                <tr class="machine-row"><td>12" Lines</td><td><input type="number" id="st_12line" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">LF</td><td class="calc-val" id="st_12line_prod">5,000</td><td class="calc-val" id="st_12line_hrs">0</td><td class="calc-val" id="st_12line_mat">$0</td></tr>
                <tr class="machine-row"><td>24" Lines</td><td><input type="number" id="st_24bar" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">LF</td><td class="calc-val" id="st_24bar_prod">3,000</td><td class="calc-val" id="st_24bar_hrs">0</td><td class="calc-val" id="st_24bar_mat">$0</td></tr>
                <tr class="hand-row"><td>HC Symbols</td><td><input type="number" id="st_hc" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">EA</td><td class="calc-val" id="st_hc_prod">80</td><td class="calc-val" id="st_hc_hrs">0</td><td class="calc-val" id="st_hc_mat">$0</td></tr>
                <tr class="hand-row"><td>Arrows</td><td><input type="number" id="st_arrow" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">EA</td><td class="calc-val" id="st_arrow_prod">50</td><td class="calc-val" id="st_arrow_hrs">0</td><td class="calc-val" id="st_arrow_mat">$0</td></tr>
                <tr class="hand-row"><td>Stencils / Lettering</td><td><input type="number" id="st_stencil" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">EA</td><td class="calc-val" id="st_stencil_prod">200</td><td class="calc-val" id="st_stencil_hrs">0</td><td class="calc-val" id="st_stencil_mat">$0</td></tr>
                <tr class="hand-row"><td>Curbing</td><td><input type="number" id="st_curb" placeholder="0" min="0" oninput="calculateAll()"></td><td class="unit">LF</td><td class="calc-val" id="st_curb_prod">5,000</td><td class="calc-val" id="st_curb_hrs">0</td><td class="calc-val" id="st_curb_mat">$0</td></tr>
            </tbody>
        </table>
        <p class="note">HC symbol count is for symbol painting only. Line footage for HC stalls is included in 4" line quantities.</p>
        <div class="output-section">
            <h5>Striping Output (Concurrency: max of machine / hand hours)</h5>
            <div class="output-row"><span class="lbl">Machine Hours (lines)</span><span class="val" id="st_machineHrs">0</span></div>
            <div class="output-row"><span class="lbl">Hand Hours (symbols/stencils/curb)</span><span class="val" id="st_handHrs">0</span></div>
            <div class="output-divider"></div>
            <div id="st_output"></div>
        </div>
        <textarea id="note_st" class="notes-box" placeholder="Reviewer notes for Striping..."></textarea>
    </div>
</div>

<!-- 4. ASPHALT REPAIRS -->
<div class="panel-wrapper" id="wt_asphalt_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_asphalt')">
        <div class="toggle-left">
            <input type="checkbox" id="en_asphalt" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-red"></span>Asphalt Repairs<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_asphalt">
        <div class="wt-grid">
            <div class="input-group"><label>Total Repair Area (SF)</label><input type="number" id="ar_sf" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Determines material layers and tonnage. Each layer adds cost. 2s=surface only, 4b=base course, d=DGA sub-base.">Depth Configuration</span></label>
                <select id="ar_depth" onchange="calculateAll()">
                    <option value="2s">2" Surface Only (9.5mm)</option>
                    <option value="2s4b">2" Surface + 4" Base (19mm)</option>
                    <option value="2s4d">2" Surface + 4" DGA</option>
                    <option value="2s4b4d">2" Surface + 4" Base + 4" DGA</option>
                    <option value="2s4b6d">2" Surface + 4" Base + 6" DGA</option>
                    <option value="2s6d">2" Surface + 6" DGA</option>
                </select>
            </div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="ar_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="ar_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <div class="output-section">
            <h5>Asphalt Repair Output</h5>
            <div class="output-row"><span class="lbl">9.5mm Surface (tons)</span><span class="val" id="ar_surfTons">0</span></div>
            <div class="output-row"><span class="lbl">19mm Base (tons)</span><span class="val" id="ar_baseTons">0</span></div>
            <div class="output-row"><span class="lbl">DGA (tons)</span><span class="val" id="ar_dgaTons">0</span></div>
            <div class="output-row highlight"><span class="lbl">Total Asphalt (tons)</span><span class="val" id="ar_totalTons">0</span></div>
            <div class="output-row"><span class="lbl">Crew Type</span><span class="val" id="ar_crewType">-</span></div>
            <div class="output-divider"></div>
            <div id="ar_output"></div>
        </div>
        <textarea id="note_ar" class="notes-box" placeholder="Reviewer notes for Asphalt Repairs..."></textarea>
    </div>
</div>

<!-- 5. MASTIC CRACK FILLING -->
<div class="panel-wrapper" id="wt_mastic_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_mastic')">
        <div class="toggle-left">
            <input type="checkbox" id="en_mastic" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-purple"></span>Mastic Crack Filling<span class="cluster-badge" style="font-size:0.65rem; color:#ef5350; margin-left:6px;">&#x1F534; Mastic</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_mastic">
        <div class="wt-grid">
            <div class="input-group"><label>Total Linear Feet (LF)</label><input type="number" id="ma_lf" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Wider cracks consume more material per LF and slow machine speed.">Avg Crack Width (inches)</span></label><input type="number" id="ma_width" value="1.0" min="0.25" step="0.25" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Deeper cracks require more mastic fill. For voids over 1 inch, pre-fill with sand to 0.5 inches from surface.">Avg Crack Depth (inches)</span></label><input type="number" id="ma_depth" value="0.5" min="0.25" step="0.25" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="ma_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="ma_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note">5-man crew: 2 dumping buckets, 2 on hot irons, 1 driving/traffic/logistics. Fifth crew member absorbs machine pickup and dropoff within production hours. Machine rental charged per production day.</p>
        <p class="note">Material: 30 lb box yields ~57.5 cu. in. of fill. Coverage per box = 57.5 / (width x depth). For deep voids, fill with sand to 1/2" from surface before mastic.</p>
        <div class="output-section"><h5>Mastic Output</h5><div id="ma_output"></div></div>
        <textarea id="note_ma" class="notes-box" placeholder="Reviewer notes for Mastic..."></textarea>
    </div>
</div>

<!-- 6. WHEEL STOPS -->
<div class="panel-wrapper" id="wt_wheelstop_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_wheelstop')">
        <div class="toggle-left">
            <input type="checkbox" id="en_wheelstop" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-teal"></span>Wheel Stops<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_wheelstop">
        <div class="wt-grid">
            <div class="input-group"><label>New Installs (qty)</label><input type="number" id="ws_new" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label>Reset / Re-pin (qty)</label><input type="number" id="ws_reset" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label>Remove & Dispose (qty)</label><input type="number" id="ws_remove" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="ws_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="ws_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <div class="output-section"><h5>Wheel Stop Output</h5><div id="ws_output"></div></div>
        <textarea id="note_ws" class="notes-box" placeholder="Reviewer notes for Wheel Stops..."></textarea>
    </div>
</div>

<!-- 7. SIGNS -->
<div class="panel-wrapper" id="wt_sign_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_sign')">
        <div class="toggle-left">
            <input type="checkbox" id="en_sign" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-green"></span>Signs<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_sign">
        <div class="wt-grid">
            <div class="input-group"><label>Signs on Post (qty)</label><input type="number" id="sg_post" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label>Signs in Bollard (qty)</label><input type="number" id="sg_bollard" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="sg_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="sg_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note">Post signs include small and large at blended rate of 32/day. Bollard signs include sign + bollard material costs.</p>
        <div class="output-section"><h5>Sign Output</h5><div id="sg_output"></div></div>
        <textarea id="note_sg" class="notes-box" placeholder="Reviewer notes for Signs..."></textarea>
    </div>
</div>

<!-- 8. BOLLARD REPLACEMENT -->
<div class="panel-wrapper" id="wt_bollard_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_bollard')">
        <div class="toggle-left">
            <input type="checkbox" id="en_bollard" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-pink"></span>Bollard Replacement<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_bollard">
        <div class="wt-grid">
            <div class="input-group"><label>Bollards (qty)</label><input type="number" id="bo_qty" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="bo_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="bo_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <div class="output-section"><h5>Bollard Output</h5><div id="bo_output"></div></div>
        <textarea id="note_bo" class="notes-box" placeholder="Reviewer notes for Bollards..."></textarea>
    </div>
</div>

<!-- 9. RUBBER SPEED BUMPS -->
<div class="panel-wrapper" id="wt_speedbump_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_speedbump')">
        <div class="toggle-left">
            <input type="checkbox" id="en_speedbump" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-cyan"></span>Rubber Speed Bumps<span class="cluster-badge" style="font-size:0.65rem; color:#42a5f5; margin-left:6px;">&#x1F537; Paint</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_speedbump">
        <div class="wt-grid">
            <div class="input-group"><label>Speed Bumps (qty)</label><input type="number" id="sb_qty" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="sb_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="sb_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <div class="output-section"><h5>Rubber Speed Bump Output</h5><div id="sb_output"></div></div>
        <textarea id="note_sb" class="notes-box" placeholder="Reviewer notes for Speed Bumps..."></textarea>
    </div>
</div>

<!-- 10. SPEED HUMPS -->
<div class="panel-wrapper" id="wt_speedhump_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_speedhump')">
        <div class="toggle-left">
            <input type="checkbox" id="en_speedhump" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-orange"></span>Asphalt Speed Humps<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_speedhump">
        <div class="wt-grid">
            <div class="input-group"><label>Speed Humps (qty)</label><input type="number" id="sh_qty" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="sh_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="sh_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note">2.13 tons of 9.5mm asphalt per hump (sinusoidal profile, 16'x13'x2.64").</p>
        <div class="output-section"><h5>Speed Hump Output</h5>
            <div class="output-row"><span class="lbl">Asphalt (tons)</span><span class="val" id="sh_tons">0</span></div>
            <div class="output-divider"></div>
            <div id="sh_output"></div>
        </div>
        <textarea id="note_sh" class="notes-box" placeholder="Reviewer notes for Speed Humps..."></textarea>
    </div>
</div>

<!-- 11. INLET REPAIR -->
<div class="panel-wrapper" id="wt_inlet_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_inlet')">
        <div class="toggle-left">
            <input type="checkbox" id="en_inlet" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-teal"></span>Inlet Repair / Reconstruction<span class="cluster-badge" style="font-size:0.65rem; color:#e67e22; margin-left:6px;">&#x1F536; Heavy</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_inlet">
        <div class="wt-grid">
            <div class="input-group"><label>Repairs (parge & asphalt, qty)</label><input type="number" id="in_repair" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label>Reconstructions (qty)</label><input type="number" id="in_recon" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label>Castings Required (qty)</label><input type="number" id="in_casting" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="in_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="in_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note">Repair = 6 units/day (4-man crew). Reconstruction hours depend on scope.</p>
        <div class="output-section"><h5>Inlet Output</h5><div id="in_output"></div></div>
        <textarea id="note_in" class="notes-box" placeholder="Reviewer notes for Inlet Repair..."></textarea>
    </div>
</div>

<!-- 12. PAINT STRIPING REMOVAL -->
<div class="panel-wrapper" id="wt_paintremoval_wrapper">
    <button class="panel-toggle" onclick="toggleWorkType(this,'wt_paintremoval')">
        <div class="toggle-left">
            <input type="checkbox" id="en_paintremoval" onclick="event.stopPropagation(); calculateAll();" checked>
            <span><span class="tag tag-pink"></span>Paint Striping Removal<span class="cluster-badge" style="font-size:0.65rem; color:#42a5f5; margin-left:6px;">&#x1F537; Paint</span></span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="wt_paintremoval">
        <div class="wt-grid">
            <div class="input-group"><label>Linear Feet (LF)</label><input type="number" id="pr_lf" placeholder="0" min="0" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Number of separate mobilizations. Each phase = one crew trip. Multi-phase adds setup/breakdown each visit.">Phases</span></label><input type="number" id="pr_phases" class="phase-input" value="1" min="1" step="1" oninput="calculateAll()"></div>
            <div class="input-group"><label><span class="tip" data-tip="Round-trip drive time added to shift hours. Billed at crew rate but outside production time.">Travel (hrs)</span></label><input type="number" id="pr_travel" class="phase-input" value="0" min="0" step="0.5" oninput="calculateAll()"></div>
        </div>
        <p class="note">Uses striping crew + grinder rental per day. Grinder runs concurrent with hand painting when both are on the same job.</p>
        <div class="output-section"><h5>Paint Removal Output</h5><div id="pr_output"></div></div>
        <textarea id="note_pr" class="notes-box" placeholder="Reviewer notes for Paint Removal..."></textarea>
    </div>
</div>

<!-- ============================================ -->
<!-- SCOPE EXCLUSIONS & ASSUMPTIONS -->
<!-- ============================================ -->
<div class="panel-wrapper">
    <button class="panel-toggle" onclick="togglePanel(this, 'scopeContent')">
        <div class="toggle-left">
            <span><span class="tag" style="background:var(--accent-orange);"></span>Scope Exclusions & Assumptions</span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="scopeContent">
        <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:0.5rem; font-style:italic;">
            Clarify what is included, excluded, or not applicable. These assumptions export with the estimate. Per ASPE Standard Estimating Practice ‚Äî every estimate should document its basis and exclusions.
        </p>
        <div id="scopeChecklist"></div>
    </div>
</div>

<!-- ============================================ -->
<!-- ESTIMATE SUMMARY -->
<!-- ============================================ -->
<div class="hb-summary">
    <h2>üìä Estimate Summary (Three-Tier Comparison)</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:1rem;">
        Crew sizes and hours per activity. Standard = Darrell's standalone rates. Conservative = 80% production. Aggressive = 120% production. Same crew for all tiers.
    </p>
    <div style="overflow-x:auto;">
        <table class="hb-table" id="hbTable">
            <thead>
                <tr>
                    <th>Activity</th>
                    <th>Crew</th>
                    <th colspan="2" style="text-align:center; color:var(--accent-orange);"><span class="tip" data-tip="80% of standard production rate. Use for complex sites, tight access, or first-time crews.">Conservative</span></th>
                    <th colspan="2" style="text-align:center; color:var(--accent-cyan);"><span class="tip" data-tip="100% production rate. Darrell's field-calibrated baseline for experienced crews.">Standard</span></th>
                    <th colspan="2" style="text-align:center; color:var(--accent-green);"><span class="tip" data-tip="120% of standard production rate. Use for wide-open sites with experienced crews.">Aggressive</span></th>
                    <th>Travel</th>
                </tr>
                <tr>
                    <th></th>
                    <th></th>
                    <th>Hours</th><th>Days</th>
                    <th>Hours</th><th>Days</th>
                    <th>Hours</th><th>Days</th>
                    <th>Hours</th>
                </tr>
            </thead>
            <tbody id="hbBody">
                <tr><td colspan="9" style="text-align:center; color:var(--text-muted); padding:1rem;">Enter quantities above to see estimate data</td></tr>
            </tbody>
        </table>
    </div>
    <textarea id="note_estimateSummary" class="notes-box" placeholder="Reviewer notes for Estimate Summary..."></textarea>
</div>

<!-- CLUSTER DEPLOYMENT SUMMARY -->
<div class="hb-summary" id="clusterSection" style="display:none; border-color: var(--accent-purple);">
    <h2 style="color: var(--accent-purple);">&#x1F4E6; Cluster Deployment Summary</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:1rem;">
        Shared mobilization applied. Hours below reflect real crew-days when activities share equipment.
    </p>
    <div id="clusterBody"></div>
    <textarea id="note_clusterSummary" class="notes-box" placeholder="Reviewer notes for Cluster Deployment..."></textarea>
</div>

<!-- ============================================ -->
<!-- ESTIMATE CONFIDENCE -->
<!-- ============================================ -->
<div class="hb-summary" id="confidenceSection" style="display:none; border-color: var(--accent-cyan);">
    <h2 style="color: var(--accent-cyan);">üõ°Ô∏è Estimate Confidence</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:1rem;">
        Composite score based on production reliability, benchmark alignment, scope definition, and data quality. Per AACE RP 42R-08.
    </p>
    <div id="confidenceBody"></div>
</div>

<!-- ============================================ -->
<!-- CALENDAR DURATION -->
<!-- ============================================ -->
<div class="hb-summary" id="calendarSection" style="display:none; border-color: var(--accent-green);">
    <h2 style="color: var(--accent-green);">üìÖ Calendar Duration Estimate</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:0.75rem;">
        Working days including cure windows and weather contingency. One block per crew cluster (standard tier).
    </p>
    <div style="display:flex; align-items:center; gap:0.5rem; margin-bottom:0.75rem;">
        <label style="font-size:0.75rem; color:var(--text-muted);">Weather Contingency Days:</label>
        <input type="number" id="weatherDays" value="0" min="0" step="1" style="width:60px;" oninput="calculateAll()">
    </div>
    <div id="calendarBody"></div>
</div>

<!-- ============================================ -->
<!-- UNIT COST REASONABLENESS CHECK -->
<!-- ============================================ -->
<div class="hb-summary" id="unitCheckSection" style="display:none;">
    <h2>üéØ Unit Cost Reasonableness Check</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:1rem;">
        Calculated all-in $/unit (labor + material + equipment, standard tier, before markup) compared against historical P25-P75 ranges from 347 jobs.
    </p>
    <div style="overflow-x:auto;">
        <table class="hb-table" id="unitCheckTable">
            <thead>
                <tr>
                    <th>Activity</th>
                    <th>Qty</th>
                    <th>Unit</th>
                    <th>Calc $/Unit</th>
                    <th><span class="tip" data-tip="25th percentile - 75% of historical jobs cost more than this.">P25</span></th>
                    <th><span class="tip" data-tip="50th percentile - typical cost from 347 historical jobs.">Median</span></th>
                    <th><span class="tip" data-tip="75th percentile - 75% of historical jobs cost less than this.">P75</span></th>
                    <th>Status</th>
                </tr>
            </thead>
            <tbody id="unitCheckBody"></tbody>
        </table>
    </div>
    <textarea id="note_unitCheck" class="notes-box" placeholder="Reviewer notes for Unit Cost Check..."></textarea>
</div>

<!-- ============================================ -->
<!-- JOB ANALYSIS -->
<!-- ============================================ -->
<div class="hb-summary" id="analysisSection" style="display:none; border-color: var(--accent-orange);">
    <h2 style="color: var(--accent-orange);">üîç Job Analysis</h2>
    <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:1rem;">
        Deterministic analysis of unit cost flags based on quantities, phases, travel, and production parameters relative to 347 historical jobs.
    </p>
    <div id="analysisBody"></div>
    <textarea id="note_analysis" class="notes-box" placeholder="Reviewer notes for Job Analysis..."></textarea>
</div>

<!-- ============================================ -->
<!-- COMBINED COST SUMMARY -->
<!-- ============================================ -->
<div class="cost-summary">
    <h2>üíµ Combined Cost Summary (Standard Tier)</h2>
    <div class="cost-grid">
        <div class="cost-category">
            <h4>Labor & Equipment by Work Type</h4>
            <div class="cost-line" id="sum_cf_row"><span class="lbl">Crack Filling</span><span class="val" id="sum_cf">$0</span></div>
            <div class="cost-line" id="sum_sc_row"><span class="lbl">Seal Coating</span><span class="val" id="sum_sc">$0</span></div>
            <div class="cost-line" id="sum_st_row"><span class="lbl">Striping</span><span class="val" id="sum_st">$0</span></div>
            <div class="cost-line" id="sum_ar_row"><span class="lbl">Asphalt Repairs</span><span class="val" id="sum_ar">$0</span></div>
            <div class="cost-line" id="sum_ma_row"><span class="lbl">Mastic Crack Fill</span><span class="val" id="sum_ma">$0</span></div>
            <div class="cost-line" id="sum_ws_row"><span class="lbl">Wheel Stops</span><span class="val" id="sum_ws">$0</span></div>
            <div class="cost-line" id="sum_sg_row"><span class="lbl">Signs</span><span class="val" id="sum_sg">$0</span></div>
            <div class="cost-line" id="sum_bo_row"><span class="lbl">Bollards</span><span class="val" id="sum_bo">$0</span></div>
            <div class="cost-line" id="sum_sb_row"><span class="lbl">Rubber Speed Bumps</span><span class="val" id="sum_sb">$0</span></div>
            <div class="cost-line" id="sum_sh_row"><span class="lbl">Speed Humps</span><span class="val" id="sum_sh">$0</span></div>
            <div class="cost-line" id="sum_in_row"><span class="lbl">Inlet Repair</span><span class="val" id="sum_in">$0</span></div>
            <div class="cost-line" id="sum_pr_row"><span class="lbl">Paint Removal</span><span class="val" id="sum_pr">$0</span></div>
            <div class="cost-line subtotal"><span class="lbl">Labor & Equip Subtotal</span><span class="val" id="sum_laborTotal">$0</span></div>
        </div>
        <div class="cost-category">
            <h4>Materials by Work Type</h4>
            <div class="cost-line" id="summ_cf_row"><span class="lbl">Crack Fill Material</span><span class="val" id="summ_cf">$0</span></div>
            <div class="cost-line" id="summ_sc_row"><span class="lbl">Sealer</span><span class="val" id="summ_sc">$0</span></div>
            <div class="cost-line" id="summ_st_row"><span class="lbl">Striping Paint</span><span class="val" id="summ_st">$0</span></div>
            <div class="cost-line" id="summ_ar_row"><span class="lbl">Asphalt / DGA</span><span class="val" id="summ_ar">$0</span></div>
            <div class="cost-line" id="summ_ma_row"><span class="lbl">Mastic + Machine</span><span class="val" id="summ_ma">$0</span></div>
            <div class="cost-line" id="summ_ws_row"><span class="lbl">Wheel Stops</span><span class="val" id="summ_ws">$0</span></div>
            <div class="cost-line" id="summ_sg_row"><span class="lbl">Signs</span><span class="val" id="summ_sg">$0</span></div>
            <div class="cost-line" id="summ_bo_row"><span class="lbl">Bollards</span><span class="val" id="summ_bo">$0</span></div>
            <div class="cost-line" id="summ_sb_row"><span class="lbl">Speed Bumps</span><span class="val" id="summ_sb">$0</span></div>
            <div class="cost-line" id="summ_sh_row"><span class="lbl">Speed Humps</span><span class="val" id="summ_sh">$0</span></div>
            <div class="cost-line" id="summ_in_row"><span class="lbl">Inlet (Block/Casting)</span><span class="val" id="summ_in">$0</span></div>
            <div class="cost-line" id="summ_pr_row"><span class="lbl">Grinder Rental</span><span class="val" id="summ_pr">$0</span></div>
            <div class="cost-line subtotal"><span class="lbl">Materials Subtotal</span><span class="val" id="sum_matTotal">$0</span></div>
        </div>
        <div class="cost-category" id="unitCostColumn" style="display:none;">
            <h4>Unit Cost Check</h4>
            <div id="unitCostColumnBody"></div>
        </div>
    </div>
    <div class="cost-totals">
        <div class="cost-total-row">
            <span class="lbl">Direct Cost Total</span>
            <span class="val" id="directCostTotal">$0</span>
        </div>
        <div class="markup-row">
            <label>Markup %</label>
            <input type="number" id="markupPercent2" value="60" step="1" oninput="syncMarkup(this); calculateAll();">
            <span style="color:var(--text-muted)">%</span>
            <span class="val" style="margin-left:auto;" id="markupAmount">$0</span>
        </div>
        <div class="cost-total-row grand">
            <span class="lbl">BID PRICE</span>
            <span class="val" id="bidPrice">$0</span>
        </div>
    </div>
    <textarea id="note_costSummary" class="notes-box" placeholder="Reviewer notes for Cost Summary..."></textarea>
</div>

<!-- HISTORICAL BENCHMARKING REFERENCE -->
<div class="panel-wrapper">
    <button class="panel-toggle" onclick="togglePanel(this, 'benchContent')">
        <div class="toggle-left">
            <span><span class="tag" style="background:var(--accent-cyan);"></span>Historical Benchmarking Reference</span>
        </div>
        <span class="arrow">‚ñº</span>
    </button>
    <div class="panel-content" id="benchContent">
        <p style="font-size:0.72rem; color:var(--text-muted); margin-bottom:0.75rem; font-style:italic;">
            All-in unit costs (labor + equipment + material) from 347 historical jobs (Dec 2024 - Dec 2025).
            Costs are heavily influenced by job size. Small quantities carry proportionally higher crew mobilization costs.
        </p>
        <div style="overflow-x:auto;">
        <table class="stripe-table" style="font-size:0.72rem;">
            <thead>
                <tr>
                    <th style="text-align:left;">Item</th>
                    <th>Unit</th>
                    <th>Median $/Unit</th>
                    <th>P25 - P75</th>
                    <th>Typical Qty Range</th>
                </tr>
            </thead>
            <tbody>
                <tr><td>Crack Fill</td><td>LF</td><td>$0.84</td><td>$0.66 - $1.14</td><td>500 - 10,000</td></tr>
                <tr><td>Sealcoat</td><td>SF</td><td>$0.11</td><td>$0.10 - $0.14</td><td>15,000 - 300,000</td></tr>
                <tr><td>4" Lines</td><td>LF</td><td>$0.53</td><td>$0.30 - $1.18</td><td>1,000 - 25,000</td></tr>
                <tr><td>Arrows</td><td>EA</td><td>$25.62</td><td>$19.87 - $36.01</td><td>5 - 50</td></tr>
                <tr><td>HC Symbols</td><td>EA</td><td>$45.66</td><td>$25.16 - $73.75</td><td>2 - 30</td></tr>
                <tr><td>Asphalt Repair</td><td>SF</td><td>$7.57</td><td>$5.10 - $14.77</td><td>50 - 2,000</td></tr>
                <tr><td>Wheel Stops (new)</td><td>UN</td><td>$88.22</td><td>$36.77 - $103.75</td><td>5 - 100</td></tr>
                <tr><td>Bollards</td><td>UN</td><td>$351.26</td><td>$173.67 - $528.84</td><td>2 - 20</td></tr>
                <tr><td>Speed Bumps (rubber)</td><td>UN</td><td>$554.62</td><td>$493.34 - $615.90</td><td>2 - 10</td></tr>
                <tr><td>Inlet Repair</td><td>UN</td><td>$969.46</td><td>$863.29 - $1,222.09</td><td>1 - 8</td></tr>
                <tr><td>Inlet Reconstruction</td><td>UN</td><td>$966.74</td><td>$835.31 - $1,459.28</td><td>1 - 4</td></tr>
            </tbody>
        </table>
        </div>
    </div>
</div>

<div class="footer">
    Maintenance Division Estimating Calculator v4.1 | Field-Calibrated Production Rates | Crew Size Adjustment | Crew Clustering | Estimate Confidence | Calendar Duration<br>
    All rates subject to superintendent review.
</div>

<div class="toast" id="toast"></div>

<script>
// ===== UTILITY FUNCTIONS =====
function gv(id) { return parseFloat(document.getElementById(id)?.value) || 0; }
function sv(id, val) { const el = document.getElementById(id); if (el) el.textContent = val; }
function fmt(n) { return '$' + n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }); }
function fmt2(n) { return n > 0 ? '$' + n.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 2 }) : '$0'; }
function isOn(id) { return document.getElementById(id)?.checked; }

const NOTE_IDS = {
    cf: 'note_cf', sc: 'note_sc', st: 'note_st', ar: 'note_ar',
    ma: 'note_ma', ws: 'note_ws', sg: 'note_sg', bo: 'note_bo',
    sb: 'note_sb', sh: 'note_sh', 'in': 'note_in', pr: 'note_pr',
    estimateSummary: 'note_estimateSummary', clusterSummary: 'note_clusterSummary',
    unitCheck: 'note_unitCheck', analysis: 'note_analysis', costSummary: 'note_costSummary'
};
const NOTE_LABELS = {
    cf: 'Crack Filling', sc: 'Sealcoating', st: 'Striping', ar: 'Asphalt Repairs',
    ma: 'Mastic', ws: 'Wheel Stops', sg: 'Signs', bo: 'Bollards',
    sb: 'Speed Bumps', sh: 'Speed Humps', 'in': 'Inlet Repair', pr: 'Paint Removal',
    estimateSummary: 'Estimate Summary', clusterSummary: 'Cluster Deployment',
    unitCheck: 'Unit Cost Check', analysis: 'Job Analysis', costSummary: 'Cost Summary'
};
function collectNotes() {
    const notes = {};
    for (const [key, id] of Object.entries(NOTE_IDS)) {
        const el = document.getElementById(id);
        if (el && el.value.trim()) notes[key] = el.value.trim();
    }
    return notes;
}

function togglePanel(btn, contentId) {
    btn.classList.toggle('open');
    document.getElementById(contentId).classList.toggle('open');
}
function toggleWorkType(btn, contentId) {
    btn.classList.toggle('open');
    document.getElementById(contentId).classList.toggle('open');
}
function showToast(msg) {
    const t = document.getElementById('toast');
    t.textContent = msg;
    t.classList.add('show');
    setTimeout(() => t.classList.remove('show'), 3000);
}
function syncMarkup(el) {
    const other = el.id === 'markupPercent' ? 'markupPercent2' : 'markupPercent';
    document.getElementById(other).value = el.value;
}

// ===== SHIFT OPTIMIZATION ENGINE =====
const SHIFT_INCREMENTS = [4, 6, 8, 10, 12];
const HUSTLE_THRESHOLD = 0.5;

// Historical benchmark ranges (P25/median/P75) from 347 jobs
// Basis: ADJUSTED = tuned empirical, EMPIRICAL = raw dataset, DERIVED = calculated from crew/rates/material
const BENCHMARKS = {
    cf:   { name: 'Crack Fill',          unit: 'LF', p25: 0.66,   med: 0.84,   p75: 1.14,   n: 52  },  // EMPIRICAL
    sc:   { name: 'Sealcoat',            unit: 'SF', p25: 0.098,  med: 0.113,  p75: 0.14,   n: 40  },  // EMPIRICAL (1yr)
    st4:  { name: '4" Lines',            unit: 'LF', p25: 0.30,   med: 0.53,   p75: 1.18,   n: 63  },  // EMPIRICAL
    st6:  { name: '6" Lines',            unit: 'LF', p25: 0.50,   med: 0.85,   p75: 1.80,   n: 0   },  // DERIVED
    st12: { name: '12" Lines',           unit: 'LF', p25: 1.67,   med: 1.93,   p75: 6.36,   n: 7   },  // EMPIRICAL
    st24: { name: '24" Lines',           unit: 'LF', p25: 1.43,   med: 4.05,   p75: 9.28,   n: 10  },  // EMPIRICAL
    stAr: { name: 'Arrows',             unit: 'EA', p25: 19.87,  med: 25.62,  p75: 36.01,  n: 30  },  // EMPIRICAL
    stHC: { name: 'HC Symbols',          unit: 'EA', p25: 25.16,  med: 45.66,  p75: 73.75,  n: 38  },  // EMPIRICAL
    stSt: { name: 'Stencils',           unit: 'EA', p25: 11.00,  med: 22.09,  p75: 46.86,  n: 20  },  // EMPIRICAL
    stCb: { name: 'Curb Paint',          unit: 'LF', p25: 0.37,   med: 0.91,   p75: 1.36,   n: 6   },  // EMPIRICAL
    ar:   { name: 'Asphalt Repair',      unit: 'SF', p25: 5.10,   med: 7.57,   p75: 14.77,  n: 36  },  // EMPIRICAL
    ma:   { name: 'Mastic Crack Fill',   unit: 'LF', p25: 5.50,   med: 6.50,   p75: 8.50,   n: 0   },  // DERIVED
    ws:   { name: 'Wheel Stops (new)',   unit: 'UN', p25: 36.77,  med: 88.22,  p75: 103.75, n: 8   },  // EMPIRICAL
    ws_r: { name: 'Wheel Stops (reset)', unit: 'UN', p25: 25.00,  med: 45.00,  p75: 75.00,  n: 0   },  // DERIVED
    ws_rm:{ name: 'Wheel Stops (remove)',unit: 'UN', p25: 30.00,  med: 50.00,  p75: 90.00,  n: 0   },  // DERIVED
    sg_sm:{ name: 'Signs (small)',       unit: 'UN', p25: 24.34,  med: 53.67,  p75: 113.84, n: 3   },  // EMPIRICAL
    sg_lg:{ name: 'Signs (large)',       unit: 'UN', p25: 217.50, med: 277.90, p75: 386.09, n: 4   },  // EMPIRICAL
    bo:   { name: 'Bollards',            unit: 'UN', p25: 173.67, med: 351.26, p75: 528.84, n: 2   },  // EMPIRICAL
    sb:   { name: 'Speed Bumps',         unit: 'UN', p25: 493.34, med: 554.62, p75: 615.90, n: 2   },  // EMPIRICAL
    sh:   { name: 'Speed Humps',         unit: 'UN', p25: 750.00, med: 950.00, p75: 1400.00,n: 0   },  // DERIVED
    in_r: { name: 'Inlet Repair',        unit: 'UN', p25: 863.29, med: 969.46, p75: 1222.09,n: 20  },  // EMPIRICAL
    in_c: { name: 'Inlet Reconstruct',   unit: 'UN', p25: 835.31, med: 966.74, p75: 1459.28,n: 18  },  // EMPIRICAL
    pr:   { name: 'Paint Removal',       unit: 'LF', p25: 0.55,   med: 0.85,   p75: 1.50,   n: 0   },  // DERIVED
};

// Typical quantity ranges from historical data (for analysis engine)
const QTY_RANGES = {
    cf:   { low: 500, high: 10000 },
    sc:   { low: 15000, high: 300000 },
    st4:  { low: 1000, high: 25000 },
    st6:  { low: 500, high: 15000 },
    st12: { low: 200, high: 5000 },
    st24: { low: 100, high: 3000 },
    stAr: { low: 5, high: 50 },
    stHC: { low: 2, high: 30 },
    stSt: { low: 5, high: 50 },
    stCb: { low: 200, high: 5000 },
    ar:   { low: 50, high: 2000 },
    ma:   { low: 500, high: 5000 },
    ws:   { low: 5, high: 100 },
    ws_r: { low: 5, high: 100 },
    ws_rm:{ low: 5, high: 50 },
    sg_sm:{ low: 2, high: 20 },
    sg_lg:{ low: 1, high: 10 },
    bo:   { low: 2, high: 20 },
    sb:   { low: 2, high: 10 },
    sh:   { low: 1, high: 8 },
    in_r: { low: 1, high: 8 },
    in_c: { low: 1, high: 4 },
    pr:   { low: 500, high: 5000 },
};

// Production rate confidence bands (from Field Ops Q17: which rates swing most)
const RATE_CONFIDENCE = {
    crackFill:     { band: 20, label: '¬±20%',  reliability: 'Moderate ‚Äî crack density and access vary' },
    sealcoat:      { band: 15, label: '¬±15%',  reliability: 'Moderate-High ‚Äî spray rig is consistent, lot complexity is the variable' },
    striping:      { band: 10, label: '¬±10%',  reliability: 'High ‚Äî machine speed is very consistent' },
    asphaltRepair: { band: 35, label: '¬±35%',  reliability: 'Low ‚Äî every patch is different (depth, sub-base condition, delamination)' },
    mastic:        { band: 20, label: '¬±20%',  reliability: 'Moderate ‚Äî machine rate is fixed but crack width variance changes material consumption' },
    wheelStops:    { band: 15, label: '¬±15%',  reliability: 'Moderate-High' },
    bollards:      { band: 25, label: '¬±25%',  reliability: 'Moderate ‚Äî removal of existing bollards is unpredictable (unknown foundation depth)' },
    speedBumps:    { band: 15, label: '¬±15%',  reliability: 'Moderate-High' },
    speedHumps:    { band: 20, label: '¬±20%',  reliability: 'Moderate' },
    inletRepair:   { band: 40, label: '¬±40%',  reliability: 'Low ‚Äî deterioration is invisible until opened; 20-30% of repairs escalate to reconstruction' },
    paintRemoval:  { band: 15, label: '¬±15%',  reliability: 'Moderate-High ‚Äî thermoplastic vs standard paint is the main variable' },
    signs:         { band: 15, label: '¬±15%',  reliability: 'Moderate-High' },
};

// Band ‚Üí confidence sub-score mapping for Feature 5
const BAND_SCORE = { 10: 0.90, 15: 0.85, 20: 0.80, 25: 0.75, 35: 0.65, 40: 0.60 };

// Calendar Duration: cure windows between dependent activities (days)
const CURE_WINDOWS = {
    crackFill_before_sealcoat: 0,  // CF crew works directly ahead of SC crew, no cure needed
    sealcoat_before_striping: 1,
    asphaltRepair_before_striping: 1
};

// Work sequence for calendar ordering
const WORK_SEQUENCE = [
    'asphaltRepair','inletRepair','crackFill','mastic','sealcoat',
    'striping','paintRemoval','wheelStops','bollards','signs','speedBumps','speedHumps'
];

// Crew Clustering: activities that share equipment and crew deploy as one physical crew
const CREW_CLUSTERS = {
    heavy: {
        id: 'heavy',
        name: 'Heavy Crew',
        icon: '\u{1F536}',  // orange diamond
        activities: ['asphaltRepair', 'wheelStops', 'bollards', 'signs', 'inletRepair', 'speedHumps'],
        description: 'Skid steer, hot box/triaxle, roller, dump truck, F550s'
    },
    paint: {
        id: 'paint',
        name: 'Paint Crew',
        icon: '\u{1F537}',  // blue diamond
        activities: ['striping', 'paintRemoval', 'speedBumps'],
        description: 'Striping machine, core drill, hand tools, F550s'
    },
    sealcoat: {
        id: 'sealcoat',
        name: 'Sealcoat Crew',
        icon: '\u{1F7E2}',  // green circle
        activities: ['sealcoat'],
        standalone: true,
        description: 'Spray rig, edging tools, barricades'
    },
    crackFill: {
        id: 'crackFill',
        name: 'Crack Fill Crew',
        icon: '\u{1F7E3}',  // purple circle
        activities: ['crackFill'],
        standalone: true,
        description: 'Routing machine, pour pot, F550'
    },
    mastic: {
        id: 'mastic',
        name: 'Mastic Crew',
        icon: '\u{1F534}',  // red circle
        activities: ['mastic'],
        standalone: true,
        description: 'Mastic machine (rented), 5-man specialized'
    }
};

// Reverse lookup: activity key -> cluster ID
const ACTIVITY_CLUSTER = {};
for (const [clusterId, cluster] of Object.entries(CREW_CLUSTERS)) {
    for (const actKey of cluster.activities) {
        ACTIVITY_CLUSTER[actKey] = clusterId;
    }
}

// Maps cluster activity keys to calculator's internal identifiers
const CLUSTER_ACTIVITY_MAP = {
    asphaltRepair: { enableId: 'en_asphalt',       snapshotKey: 'asphaltRepair' },
    wheelStops:    { enableId: 'en_wheelstop',     snapshotKey: 'wheelStops' },
    bollards:      { enableId: 'en_bollard',       snapshotKey: 'bollards' },
    signs:         { enableId: 'en_sign',          snapshotKey: 'signs' },
    inletRepair:   { enableId: 'en_inlet',         snapshotKey: 'inletRepair' },
    speedHumps:    { enableId: 'en_speedhump',     snapshotKey: 'speedHumps' },
    striping:      { enableId: 'en_striping',      snapshotKey: 'striping' },
    paintRemoval:  { enableId: 'en_paintremoval',  snapshotKey: 'paintRemoval' },
    speedBumps:    { enableId: 'en_speedbump',     snapshotKey: 'speedBumps' },
    sealcoat:      { enableId: 'en_sealcoat',      snapshotKey: 'sealcoat' },
    crackFill:     { enableId: 'en_crackfill',     snapshotKey: 'crackFill' },
    mastic:        { enableId: 'en_mastic',        snapshotKey: 'mastic' }
};

// === CREW SIZE ADJUSTMENT ===
// Base crew sizes each all-in crew rate was calibrated at. When the user
// changes crew size, delta members are priced at the laborer adjustment rate.
// Sealcoat application method configurations
// Production rates from Darrell Bishop field data (Feb 2026):
//   Wand only 3-man: 15K SF/day (2-coat, 8hr day)
//   Spray rig + wand 4-man: 52K SF/day (manual bar needs dedicated operator)
//   Dual wand 6-man: 30K SF/day (two 3-man wand teams, schedule compression)
const SEALCOAT_METHODS = {
    wandOnly:  { label: 'Wand Only',          prodRate: 15000, baseCrew: 3, note: 'Wand Only: 3-man crew, all hand-spray. 15K SF/day realistic (2-coat, 8hr). Best for tight lots, apartments, heavy edge work.' },
    sprayRig:  { label: 'Spray Rig + Wand',   prodRate: 52000, baseCrew: 4, note: 'Spray Rig: 4-man crew (4th operates manual spray bar). 52K SF/day open lot, 42-45K complex. 2-coat at 100 SF/gal, 125 gal/hr sustained.' },
    dualWand:  { label: 'Dual Wand',           prodRate: 30000, baseCrew: 6, note: 'Dual Wand: 6-man crew (two 3-man wand teams). ~30K SF/day. Schedule compression for larger jobs without second rig.' }
};

/** Apply sealcoat method defaults to production rate, crew size, and note */
function applySealcoatMethod() {
    const method = document.getElementById('sc_method').value;
    const cfg = SEALCOAT_METHODS[method];
    if (!cfg) return;
    document.getElementById('prodSealcoat').value = cfg.prodRate;
    document.getElementById('crewSealcoat').value = cfg.baseCrew;
    document.getElementById('sc_methodNote').textContent = cfg.note;
}

const BASE_CREW_SIZES = {
    crackFill:    3,
    sealcoat:     4,  // dynamic ‚Äî overridden by SEALCOAT_METHODS based on sc_method
    striping:     4,
    asphaltSmall: 4,
    asphaltLarge: 4,
    wsInstall:    3,   // wheel stops (all operations share one crew)
    speedBump:    3,
    bollard:      4,
    sign:         4,
    mastic:       4,
    inlet:        4,
    speedHump:    4
};

/**
 * Returns the effective crew hourly rate adjusted for crew size changes.
 * Formula: baseRate + (currentCrew ‚àí baseCrew) √ó laborerRate
 * If crew shrinks below base, rate decreases (laborer removed from truck).
 * @param {number} baseRate   - The all-in crew hourly rate from Rate Config
 * @param {number} currentCrew - Current crew size from input
 * @param {number} baseCrew   - Base crew size the rate was calibrated at
 * @returns {number} Adjusted crew hourly rate
 */
function adjustedRate(baseRate, currentCrew, baseCrew) {
    const laborerRate = gv('rateLaborerAdj');
    const delta = currentCrew - baseCrew;
    return baseRate + (delta * laborerRate);
}

/** Build crew adjustment info object for renderTierTable display */
function crewAdjInfo(currentCrew, baseCrew) {
    const delta = currentCrew - baseCrew;
    return { delta, laborerRate: gv('rateLaborerAdj') };
}

// === SCOPE EXCLUSIONS & ASSUMPTIONS ===
const SCOPE_ITEMS = [
    // Default INCLUDED
    { id: 'saw_cutting',      name: 'Saw Cutting',                    default: 'included', group: 'included' },
    { id: 'barricading',      name: 'Barricading / Coning',           default: 'included', group: 'included' },
    { id: 'material_hauling', name: 'Material Hauling & Delivery',    default: 'included', group: 'included' },
    // Default EXCLUDED
    { id: 'traffic_control',  name: 'Traffic Control (flagging/MOT)', default: 'excluded', group: 'excluded' },
    { id: 'permits',          name: 'Permits & Fees',                 default: 'excluded', group: 'excluded' },
    { id: 'survey_layout',    name: 'Survey / Layout / Staking',      default: 'excluded', group: 'excluded' },
    { id: 'quality_testing',  name: 'Quality Testing / Inspection',   default: 'excluded', group: 'excluded' },
    { id: 'disposal',         name: 'Off-site Disposal',              default: 'excluded', group: 'excluded' },
    { id: 'night_premium',    name: 'Night / Weekend Premium',        default: 'excluded', group: 'excluded' },
    { id: 'temp_markings',    name: 'Temporary Pavement Markings',    default: 'excluded', group: 'excluded' },
    { id: 'concrete_work',    name: 'Concrete Work (curb/sidewalk)',   default: 'excluded', group: 'excluded' },
    { id: 'landscape',        name: 'Landscaping Restoration',        default: 'excluded', group: 'excluded' }
];

function renderScopeChecklist() {
    const container = document.getElementById('scopeChecklist');
    if (!container) return;
    let html = '';
    const groups = { included: [], excluded: [] };
    SCOPE_ITEMS.forEach(item => groups[item.group].push(item));

    html += '<div class="scope-section-header incl">Default Included</div>';
    groups.included.forEach(item => { html += scopeItemHtml(item); });
    html += '<div class="scope-section-header excl" style="margin-top:1rem;">Default Excluded</div>';
    groups.excluded.forEach(item => { html += scopeItemHtml(item); });

    container.innerHTML = html;
}

function scopeItemHtml(item) {
    const id = item.id;
    return `<div class="scope-item">
        <span class="scope-item-name">${item.name}</span>
        <div class="scope-radio-group">
            <input type="radio" name="scope_${id}" id="scope_${id}_incl" value="included" ${item.default === 'included' ? 'checked' : ''}>
            <label for="scope_${id}_incl" class="lbl-incl">Incl</label>
            <input type="radio" name="scope_${id}" id="scope_${id}_excl" value="excluded" ${item.default === 'excluded' ? 'checked' : ''}>
            <label for="scope_${id}_excl" class="lbl-excl">Excl</label>
            <input type="radio" name="scope_${id}" id="scope_${id}_na" value="na">
            <label for="scope_${id}_na" class="lbl-na">N/A</label>
        </div>
        <div class="scope-item-note">
            <input type="text" id="scope_note_${id}" placeholder="Note (optional)...">
        </div>
    </div>`;
}

function collectAssumptions() {
    const result = { included: [], excluded: [], na: [] };
    SCOPE_ITEMS.forEach(item => {
        const radio = document.querySelector(`input[name="scope_${item.id}"]:checked`);
        const noteEl = document.getElementById(`scope_note_${item.id}`);
        const state = radio ? radio.value : item.default;
        const note = noteEl ? noteEl.value.trim() : '';
        const entry = { id: item.id, name: item.name, note };
        if (state === 'included') result.included.push(entry);
        else if (state === 'excluded') result.excluded.push(entry);
        else result.na.push(entry);
    });
    return result;
}

// Snap raw hours to next billing increment, with hustle detection at stdShift boundary
function snapWithHustle(hrs, stdShift) {
    for (let i = 0; i < SHIFT_INCREMENTS.length; i++) {
        const inc = SHIFT_INCREMENTS[i];
        if (hrs <= inc) return { hours: inc, hustle: false };
        // Hustle zone: slightly over an increment that equals the standard shift
        if (inc === stdShift && hrs < inc + HUSTLE_THRESHOLD) {
            return { hours: inc, hustle: true };
        }
    }
    // Past all increments but within hustle of last
    const maxInc = SHIFT_INCREMENTS[SHIFT_INCREMENTS.length - 1];
    if (hrs < maxInc + HUSTLE_THRESHOLD) return { hours: maxInc, hustle: true };
    return { hours: maxInc, hustle: false };
}

// Core shift optimizer: finds most efficient shift combination
// Returns { hours, days, hustle }
function optimizeShifts(rawHrs, stdShift, maxShift, minDays) {
    if (rawHrs <= 0 && minDays <= 0) return { hours: 0, days: 0, hustle: false };
    if (rawHrs <= 0 && minDays > 0) return { hours: 4 * minDays, days: minDays, hustle: false };

    // Single day: fits within max shift (plus hustle zone)
    if (rawHrs <= maxShift + HUSTLE_THRESHOLD && minDays <= 1) {
        const s = snapWithHustle(rawHrs, stdShift);
        return { hours: s.hours, days: 1, hustle: s.hustle };
    }

    // Multi-day: try different base shift lengths, pick best
    function tryBase(base) {
        let fullDays = Math.floor(rawHrs / base);
        let remainder = rawHrs - fullDays * base;
        if (Math.abs(remainder) < 0.01) remainder = 0;

        if (remainder === 0) {
            return { hours: fullDays * base, days: fullDays, hustle: false };
        }

        // Try extending last full day to absorb remainder
        if (fullDays > 0) {
            const extended = base + remainder;
            if (extended <= maxShift + HUSTLE_THRESHOLD) {
                const s = snapWithHustle(extended, stdShift);
                return { hours: (fullDays - 1) * base + s.hours, days: fullDays, hustle: s.hustle };
            }
        }

        // Need additional day for remainder
        const s = snapWithHustle(remainder, stdShift);
        return { hours: fullDays * base + s.hours, days: fullDays + 1, hustle: s.hustle };
    }

    let best = tryBase(stdShift);
    if (maxShift !== stdShift) {
        const ext = tryBase(maxShift);
        if (ext.hours < best.hours || (ext.hours === best.hours && ext.days < best.days)) {
            best = ext;
        }
    }

    // Apply minDays floor (phase-driven)
    if (best.days < minDays) {
        const perDay = rawHrs / minDays;
        const s = snapWithHustle(perDay, stdShift);
        best = { hours: s.hours * minDays, days: minDays, hustle: s.hustle };
    }

    return best;
}

// ===== PRODUCTION TO SHIFT HOURS =====
function calcPhasedHours(qty, prodPerDay, stdShift, maxShift, phases) {
    if (qty <= 0) return { hours: 0, days: 0, hustle: false, rawHrs: 0 };
    const safeProd = Math.max(prodPerDay, 0.01); // div-by-zero guard
    const rawHrs = (qty / safeProd) * stdShift;
    const result = optimizeShifts(rawHrs, stdShift, maxShift, phases);
    result.rawHrs = rawHrs;
    return result;
}

// ===== THREE-TIER CALCULATOR =====
function calcThreeTier(qty, prodPerDay, stdShift, maxShift, phases, stdCrew) {
    if (qty <= 0) return null;

    const std = calcPhasedHours(qty, prodPerDay, stdShift, maxShift, phases);
    const cons = calcPhasedHours(qty, prodPerDay * 0.80, stdShift, maxShift, phases);
    const agg = calcPhasedHours(qty, prodPerDay * 1.20, stdShift, maxShift, phases);

    return {
        cons: { crew: stdCrew, hours: cons.hours, days: cons.days, hustle: cons.hustle },
        std:  { crew: stdCrew, hours: std.hours, days: std.days, hustle: std.hustle },
        agg:  { crew: stdCrew, hours: agg.hours, days: agg.days, hustle: agg.hustle }
    };
}

// ===== RENDER STANDARD OUTPUT INTO WORK TYPE PANEL =====
function renderTierTable(containerId, tierData, rate, matCost, extra, travelHrs, travelCost, crewAdj) {
    const el = document.getElementById(containerId);
    if (!el) return;
    if (!tierData) {
        el.innerHTML = '<div class="output-row"><span class="lbl">No quantity entered</span><span class="val">-</span></div>';
        return;
    }

    const { std } = tierData;
    const extraCost = extra || 0;
    const laborCost = std.hours * rate;
    const tvlCost = travelCost || 0;
    const tvlHrs = travelHrs || 0;

    let html = '';
    html += `<div class="output-row"><span class="lbl">Crew Size</span><span class="val">${std.crew}</span></div>`;
    // Show crew rate adjustment indicator when crew size differs from base
    if (crewAdj && crewAdj.delta !== 0) {
        const sign = crewAdj.delta > 0 ? '+' : '';
        const adjAmt = crewAdj.delta * crewAdj.laborerRate;
        const adjSign = adjAmt >= 0 ? '+' : '-';
        html += `<div class="output-row" style="color:#00bcd4;font-size:0.68rem;"><span class="lbl">‚Ü≥ Rate adj: ${sign}${crewAdj.delta} laborer${Math.abs(crewAdj.delta) > 1 ? 's' : ''} √ó $${crewAdj.laborerRate.toFixed(2)}/hr</span><span class="val">${adjSign}$${Math.abs(adjAmt).toFixed(2)}/hr</span></div>`;
    }
    html += `<div class="output-row"><span class="lbl">Shift Hours</span><span class="val">${std.hours.toFixed(1)}</span></div>`;
    html += `<div class="output-row"><span class="lbl">Days</span><span class="val">${std.days}</span></div>`;
    if (std.hustle) {
        html += `<div class="output-row" style="color:#ffaa00;font-size:0.7rem;"><span class="lbl">&#9889; Crew can hustle to stay within shift</span><span class="val"></span></div>`;
    }
    if (tvlHrs > 0) {
        html += `<div class="output-row"><span class="lbl">Travel Time</span><span class="val">${tvlHrs.toFixed(1)} hrs</span></div>`;
    }
    html += `<div class="output-divider"></div>`;
    html += `<div class="output-row cost"><span class="lbl">Labor & Equip (shift)</span><span class="val">${fmt(laborCost)}</span></div>`;
    if (tvlCost > 0) {
        html += `<div class="output-row cost"><span class="lbl">Labor & Equip (travel)</span><span class="val">${fmt(tvlCost)}</span></div>`;
    }
    html += `<div class="output-row cost"><span class="lbl">Material</span><span class="val">${fmt(matCost)}</span></div>`;
    if (extra) {
        html += `<div class="output-row cost"><span class="lbl">Equipment/Rental</span><span class="val">${fmt(extra)}</span></div>`;
    }
    html += `<div class="output-row highlight"><span class="lbl">Total</span><span class="val">${fmt(laborCost + tvlCost + matCost + extraCost)}</span></div>`;

    el.innerHTML = html;
}

// ===== ASPHALT PRICE WARNING =====
function checkAsphaltPrices() {
    const warn = document.getElementById('asphaltWarning');
    if (!warn) return;

    let warnings = [];
    const arActive = isOn('en_asphalt') && gv('ar_sf') > 0;
    const shActive = isOn('en_speedhump') && gv('sh_qty') > 0;

    if (arActive) {
        const depth = document.getElementById('ar_depth').value;
        // All configs use 9.5mm surface (2s)
        if (!gv('asphaltPrice')) warnings.push('9.5mm surface asphalt price is empty');
        // Configs with 4b use 19mm base
        if (depth.includes('4b') && !gv('baseAsphaltPrice')) warnings.push('19mm base asphalt price is empty');
        // Configs with d use DGA
        if (depth.includes('d') && !gv('dgaPrice')) warnings.push('DGA price is empty');
    }
    if (shActive && !gv('asphaltPrice')) {
        if (!warnings.some(w => w.includes('9.5mm'))) warnings.push('9.5mm asphalt price is empty (speed humps)');
    }

    if (warnings.length > 0) {
        warn.innerHTML = '&#9888; ' + warnings.join(' &#8226; ') + '. Affected material costs will be $0.';
        warn.style.display = 'block';
    } else {
        warn.style.display = 'none';
    }
}

// ===== CREW CLUSTERING ENGINE =====
// Groups co-deployable activities and snaps once per physical crew
// Returns an object with cluster results, or null if clustering is off
function clusterize(snapshot, stdShift, maxShift) {
    if (document.getElementById('clusterMode').value !== 'on') return null;

    const activeClusters = {};

    // Step 1: Identify which clusters have active activities
    for (const [actKey, mapping] of Object.entries(CLUSTER_ACTIVITY_MAP)) {
        const actData = snapshot.activities[mapping.snapshotKey];
        if (!actData || !actData.enabled) continue;

        const clusterId = ACTIVITY_CLUSTER[actKey];
        if (!activeClusters[clusterId]) {
            activeClusters[clusterId] = {
                ...CREW_CLUSTERS[clusterId],
                activeActivities: [],
                totalRawProductionHrs: 0,
                primaryActivity: null,
                primaryHrs: 0
            };
        }

        const rawProductionHrs = actData.rawProductionHrs || 0;
        const travel = actData.inputs?.travel || 0;

        // Get the crew rate for this activity (used for cost apportioning)
        let crewRate = actData.rates?.crewRate || 0;
        // Wheel stops use blendedRate
        if (actKey === 'wheelStops' && actData.blendedRate) crewRate = actData.blendedRate;

        activeClusters[clusterId].activeActivities.push({
            actKey,
            snapshotKey: mapping.snapshotKey,
            name: actData.inputs?.lf !== undefined ? actKey.replace(/([A-Z])/g, ' $1').trim() : actKey.replace(/([A-Z])/g, ' $1').trim(),
            rawProductionHrs,
            travel,
            standaloneTier: actData.tiers,
            crewSize: actData.rates?.crewSize || actData.tiers?.std?.crew || 4,
            crewRate
        });
        activeClusters[clusterId].totalRawProductionHrs += rawProductionHrs;

        if (rawProductionHrs > activeClusters[clusterId].primaryHrs) {
            activeClusters[clusterId].primaryHrs = rawProductionHrs;
            activeClusters[clusterId].primaryActivity = actKey;
        }
    }

    // Step 2: For each cluster with 2+ activities, run cluster-level optimization
    for (const cluster of Object.values(activeClusters)) {
        if (cluster.activeActivities.length <= 1) {
            // Single activity: pass through unchanged, no clustering benefit
            cluster.clusteringApplied = false;
            if (cluster.activeActivities.length === 1) {
                const act = cluster.activeActivities[0];
                act.apportionedHrs = act.standaloneTier?.std?.hours || 0;
                act.apportionedDays = act.standaloneTier?.std?.days || 0;
                act.proportion = 1;
            }
            continue;
        }

        cluster.clusteringApplied = true;

        // Maximum travel across activities in this cluster (they share one trip)
        const maxTravel = Math.max(...cluster.activeActivities.map(a => a.travel));

        // Snap the combined production hours to a shift increment
        const combinedRaw = cluster.totalRawProductionHrs;
        const snapped = optimizeShifts(combinedRaw, stdShift, maxShift, 1);

        cluster.clusterSnapped = snapped;
        cluster.clusterTravel = maxTravel;
        cluster.clusterTotalHrs = snapped.hours;

        // Calculate what standalone total would have been (for comparison)
        cluster.standaloneTotal = cluster.activeActivities.reduce(
            (sum, a) => sum + (a.standaloneTier?.std?.hours || 0), 0
        );
        cluster.hoursSaved = cluster.standaloneTotal - snapped.hours;

        // Step 3: Apportion snapped hours back to activities proportionally
        const totalRaw = cluster.totalRawProductionHrs;
        for (const act of cluster.activeActivities) {
            if (totalRaw > 0) {
                const proportion = act.rawProductionHrs / totalRaw;
                act.apportionedHrs = Math.round(proportion * snapped.hours * 10) / 10;
                act.proportion = proportion;
            } else {
                act.apportionedHrs = 0;
                act.proportion = 0;
            }
        }

        // Reconcile rounding so apportioned hours sum exactly to cluster total
        const apportionedSum = cluster.activeActivities.reduce((s, a) => s + a.apportionedHrs, 0);
        const diff = snapped.hours - apportionedSum;
        if (Math.abs(diff) > 0.05) {
            const primary = cluster.activeActivities.find(a => a.actKey === cluster.primaryActivity);
            if (primary) {
                primary.apportionedHrs = Math.round((primary.apportionedHrs + diff) * 10) / 10;
            }
        }

        // All activities in the cluster happen on the same day(s)
        for (const act of cluster.activeActivities) {
            act.apportionedDays = snapped.days;
        }
    }

    return activeClusters;
}

// ===== MAIN CALCULATION =====
function calculateAll() {
    let stdShift = gv('hoursPerDay');
    let maxShift = gv('maxShift');
    // Enforce maxShift >= stdShift
    if (maxShift < stdShift) {
        maxShift = stdShift;
        document.getElementById('maxShift').value = stdShift;
    }
    const asphaltPrice = gv('asphaltPrice');
    const baseAsphaltPrice = gv('baseAsphaltPrice');
    const dgaPrice = gv('dgaPrice');

    // Waste factors
    const wf = {
        cf: 1 + (gv('wasteCrackFill') / 100),
        sc: 1 + (gv('wasteSealcoat') / 100),
        st: 1 + (gv('wasteStriping') / 100),
        ar: 1 + (gv('wasteAsphalt') / 100),
        ma: 1 + (gv('wasteMastic') / 100),
        sh: 1 + (gv('wasteSpeedHump') / 100),
    };

    let sumLabor = {}, sumMat = {};
    const workTypes = ['cf','sc','st','ar','ma','ws','sg','bo','sb','sh','in','pr'];
    workTypes.forEach(k => { sumLabor[k] = 0; sumMat[k] = 0; });

    let hbRows = [];
    let unitChecks = [];
    let snapshot = { activities: {} };

    // === CRACK FILLING ===
    if (isOn('en_crackfill')) {
        const lf = gv('cf_lf');
        const baseRate = gv('rateCrackFill');
        const prod = gv('prodCrackFill');
        const phases = Math.max(gv('cf_phases'), 1);
        const crew = gv('crewCrackFill');
        const rate = adjustedRate(baseRate, crew, BASE_CREW_SIZES.crackFill);
        const travel = gv('cf_travel');
        const matQty = lf * wf.cf;
        const matCost = matQty * gv('matCrackFill');
        const tier = calcThreeTier(lf, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * rate;
        renderTierTable('cf_output', tier, rate, matCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.crackFill));
        if (tier) {
            sumLabor.cf = tier.std.hours * rate + travelCost;
            sumMat.cf = matCost;
            hbRows.push({ name: 'Crack Filling', tier, travel });
            snapshot.activities.crackFill = { enabled: true, rawProductionHrs: (lf / Math.max(prod, 0.01)) * stdShift, inputs: { lf, phases, travel }, rates: { crewRate: rate, baseCrewRate: baseRate, prodPerDay: prod, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.crackFill }, tiers: tier, costs: { laborShift: tier.std.hours * rate, laborTravel: travelCost, material: matCost, total: sumLabor.cf + sumMat.cf } };
        }
    } else { renderTierTable('cf_output', null); }

    // === SEALCOATING ===
    if (isOn('en_sealcoat')) {
        const sf = gv('sc_sf');
        const scMethod = document.getElementById('sc_method').value;
        const scBaseCrew = (SEALCOAT_METHODS[scMethod] || SEALCOAT_METHODS.sprayRig).baseCrew;
        const baseRate = gv('rateSealcoat');
        const prod = gv('prodSealcoat');
        const phases = Math.max(gv('sc_phases'), 1);
        const crew = gv('crewSealcoat');
        const rate = adjustedRate(baseRate, crew, scBaseCrew);
        const travel = gv('sc_travel');
        const matQty = sf * wf.sc;
        const matCost = matQty * gv('matSealcoat');
        const tier = calcThreeTier(sf, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * rate;
        renderTierTable('sc_output', tier, rate, matCost, 0, travel, travelCost, crewAdjInfo(crew, scBaseCrew));
        if (tier) {
            sumLabor.sc = tier.std.hours * rate + travelCost;
            sumMat.sc = matCost;
            hbRows.push({ name: 'Sealcoating', tier, travel });
            snapshot.activities.sealcoat = { enabled: true, rawProductionHrs: (sf / Math.max(prod, 0.01)) * stdShift, inputs: { sf, phases, travel, method: scMethod }, rates: { crewRate: rate, baseCrewRate: baseRate, prodPerDay: prod, crewSize: crew, baseCrewSize: scBaseCrew }, tiers: tier, costs: { laborShift: tier.std.hours * rate, laborTravel: travelCost, material: matCost, total: sumLabor.sc + sumMat.sc } };
        }
    } else { renderTierTable('sc_output', null); }

    // === STRIPING (with concurrency) ===
    if (isOn('en_striping')) {
        const baseRate = gv('rateStriping');
        const phases = Math.max(gv('st_phases'), 1);
        const crew = gv('crewStriping');
        const rate = adjustedRate(baseRate, crew, BASE_CREW_SIZES.striping);
        const travel = gv('st_travel');
        const wasteFactor = wf.st;

        const machineItems = [
            { qtyId:'st_4line', prodId:'prod4Line', matId:'mat4Line', hrsId:'st_4line_hrs', matOutId:'st_4line_mat', prodOutId:'st_4line_prod' },
            { qtyId:'st_6line', prodId:'prod6Line', matId:'mat6Line', hrsId:'st_6line_hrs', matOutId:'st_6line_mat', prodOutId:'st_6line_prod' },
            { qtyId:'st_12line', prodId:'prod12Line', matId:'mat12Line', hrsId:'st_12line_hrs', matOutId:'st_12line_mat', prodOutId:'st_12line_prod' },
            { qtyId:'st_24bar', prodId:'prod24Bar', matId:'mat24Line', hrsId:'st_24bar_hrs', matOutId:'st_24bar_mat', prodOutId:'st_24bar_prod' },
        ];
        const handItems = [
            { qtyId:'st_hc', prodId:'prodHC', matId:'matHC', hrsId:'st_hc_hrs', matOutId:'st_hc_mat', prodOutId:'st_hc_prod' },
            { qtyId:'st_arrow', prodId:'prodArrow', matId:'matArrow', hrsId:'st_arrow_hrs', matOutId:'st_arrow_mat', prodOutId:'st_arrow_prod' },
            { qtyId:'st_stencil', prodId:'prodStencil', matId:'matStencil', hrsId:'st_stencil_hrs', matOutId:'st_stencil_mat', prodOutId:'st_stencil_prod' },
            { qtyId:'st_curb', prodId:'prodCurb', matId:'matCurb', hrsId:'st_curb_hrs', matOutId:'st_curb_mat', prodOutId:'st_curb_prod' },
        ];

        let machineHrs = 0, handHrs = 0, totalMat = 0;
        let lineItemData = [];

        function calcStripingGroup(items, groupName) {
            let groupHrs = 0;
            items.forEach(item => {
                const qty = gv(item.qtyId);
                const prod = Math.max(gv(item.prodId), 0.01);
                const matUnit = gv(item.matId);
                const itemHrs = qty > 0 ? (qty / prod) * stdShift : 0;
                const itemMat = qty * matUnit * wasteFactor;
                groupHrs += itemHrs;
                totalMat += itemMat;
                sv(item.hrsId, itemHrs.toFixed(1));
                sv(item.matOutId, fmt2(itemMat));
                sv(item.prodOutId, prod.toLocaleString());
                if (qty > 0) lineItemData.push({ id: item.qtyId, qty, prod, hours: itemHrs, matCost: itemMat, group: groupName });
            });
            return groupHrs;
        }

        machineHrs = calcStripingGroup(machineItems, 'machine');
        handHrs = calcStripingGroup(handItems, 'hand');
        const concurrentHrs = Math.max(machineHrs, handHrs);

        sv('st_machineHrs', machineHrs.toFixed(1));
        sv('st_handHrs', handHrs.toFixed(1));

        if (concurrentHrs > 0) {
            // Optimize shifts for each tier using concurrent hours
            function stripeTier(factor) {
                const adjHrs = concurrentHrs / factor;
                return optimizeShifts(adjHrs, stdShift, maxShift, phases);
            }
            const stdR = stripeTier(1.0);
            const consR = stripeTier(0.80);
            const aggR = stripeTier(1.20);

            const tier = {
                cons: { crew: crew, hours: consR.hours, days: consR.days, hustle: consR.hustle },
                std:  { crew: crew, hours: stdR.hours, days: stdR.days, hustle: stdR.hustle },
                agg:  { crew: crew, hours: aggR.hours, days: aggR.days, hustle: aggR.hustle }
            };

            const travelCost = travel * rate;
            renderTierTable('st_output', tier, rate, totalMat, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.striping));
            sumLabor.st = stdR.hours * rate + travelCost;
            sumMat.st = totalMat;
            hbRows.push({ name: 'Striping', tier, travel, note: `Mach: ${machineHrs.toFixed(1)}h / Hand: ${handHrs.toFixed(1)}h / Concurrent: ${concurrentHrs.toFixed(1)}h` });
            snapshot.activities.striping = { enabled: true, rawProductionHrs: concurrentHrs, inputs: { phases, travel }, lineItems: lineItemData, concurrency: { machineHrs, handHrs, concurrentHrs }, rates: { crewRate: rate, baseCrewRate: baseRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.striping }, tiers: tier, costs: { laborShift: stdR.hours * rate, laborTravel: travelCost, material: totalMat, total: sumLabor.st + sumMat.st } };
        } else {
            renderTierTable('st_output', null);
        }
    } else {
        ['st_machineHrs','st_handHrs'].forEach(id => sv(id, '0'));
        renderTierTable('st_output', null);
    }

    // === ASPHALT REPAIRS ===
    if (isOn('en_asphalt')) {
        const sf = gv('ar_sf');
        const depthConfig = document.getElementById('ar_depth').value;
        const prod = gv('prodAsphaltRepair');
        const phases = Math.max(gv('ar_phases'), 1);
        const travel = gv('ar_travel');

        const sy = sf / 9;
        let surfTons = 0, baseTons = 0, dgaTons = 0;
        if (sf > 0) {
            if (depthConfig.includes('2s')) surfTons = Math.ceil(sy * 2 * 0.0575 * wf.ar);
            if (depthConfig.includes('4b')) baseTons = Math.ceil(sy * 4 * 0.0575 * wf.ar);
            if (depthConfig.includes('4d')) dgaTons = Math.ceil((sf * 4 / 324) * 1.9 * wf.ar);
            if (depthConfig.includes('6d')) dgaTons = Math.ceil((sf * 6 / 324) * 1.9 * wf.ar);
        }

        const totalAsphaltTons = surfTons + baseTons;
        const crewIsLarge = totalAsphaltTons > 4;
        const baseCrewRate = crewIsLarge ? gv('rateAsphaltLarge') : gv('rateAsphaltSmall');
        const crew = crewIsLarge ? gv('crewAsphaltLarge') : gv('crewAsphaltSmall');
        const baseCrew = crewIsLarge ? BASE_CREW_SIZES.asphaltLarge : BASE_CREW_SIZES.asphaltSmall;
        const crewRate = adjustedRate(baseCrewRate, crew, baseCrew);
        const matAsphalt = (surfTons * asphaltPrice) + (baseTons * baseAsphaltPrice);
        const matDGA = dgaTons * dgaPrice;
        const totalMat = matAsphalt + matDGA;

        sv('ar_surfTons', surfTons);
        sv('ar_baseTons', baseTons);
        sv('ar_dgaTons', dgaTons);
        sv('ar_totalTons', totalAsphaltTons);
        sv('ar_crewType', crewIsLarge ? '> 4T (Triaxle + crew @ $' + crewRate.toFixed(2) + '/hr)' : '‚â§ 4T (Hot Box + crew @ $' + crewRate.toFixed(2) + '/hr)');

        const tier = calcThreeTier(sf, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * crewRate;
        renderTierTable('ar_output', tier, crewRate, totalMat, 0, travel, travelCost, crewAdjInfo(crew, baseCrew));
        if (tier) {
            sumLabor.ar = tier.std.hours * crewRate + travelCost;
            sumMat.ar = totalMat;
            hbRows.push({ name: 'Asphalt Repair', tier, travel });
            snapshot.activities.asphaltRepair = { enabled: true, rawProductionHrs: (sf / Math.max(prod, 0.01)) * stdShift, inputs: { sf, depthConfig, phases, travel }, tonnage: { surfTons, baseTons, dgaTons, totalAsphaltTons }, crewType: crewIsLarge ? 'large' : 'small', rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: baseCrew, prodPerDay: prod }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, matAsphalt, matDGA, material: totalMat, total: sumLabor.ar + sumMat.ar } };
        }
    } else {
        ['ar_surfTons','ar_baseTons','ar_dgaTons','ar_totalTons'].forEach(id => sv(id, '0'));
        sv('ar_crewType', '-');
        renderTierTable('ar_output', null);
    }

    // === MASTIC ===
    if (isOn('en_mastic')) {
        const lf = gv('ma_lf');
        const baseCrewRate = gv('rateMastic');
        const prod = gv('prodMastic');
        const phases = Math.max(gv('ma_phases'), 1);
        const crew = gv('crewMastic');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.mastic);
        const travel = gv('ma_travel');
        const crackWidth = gv('ma_width') || 1.0;
        const crackDepth = gv('ma_depth') || 0.5;
        const boxPrice = gv('matMasticBox');
        const machinePerDay = gv('matMasticMachine');

        if (lf > 0) {
            const crossSection = crackWidth * crackDepth;
            const lfPerBox = crossSection > 0 ? 57.5 / crossSection : 230;
            const boxesNeeded = Math.ceil((lf / lfPerBox) * wf.ma);

            const tier = calcThreeTier(lf, prod, stdShift, maxShift, phases, crew);
            const machineRental = tier.std.days * machinePerDay;
            const material = boxesNeeded * boxPrice;
            const travelCost = travel * crewRate;

            const el = document.getElementById('ma_output');
            let html = '';
            html += `<div class="output-row"><span class="lbl">Coverage per Box (at ${crackWidth}" x ${crackDepth}")</span><span class="val">${lfPerBox.toFixed(1)} LF</span></div>`;
            html += `<div class="output-row highlight"><span class="lbl">Boxes Required (30 lb)</span><span class="val">${boxesNeeded}</span></div>`;
            html += `<div class="output-divider"></div>`;
            html += `<div class="output-row"><span class="lbl">Crew Size</span><span class="val">${tier.std.crew}</span></div>`;
            { const maDelta = crew - BASE_CREW_SIZES.mastic; if (maDelta !== 0) { const maLR = gv('rateLaborerAdj'); const maAdj = maDelta * maLR; html += `<div class="output-row" style="color:#00bcd4;font-size:0.68rem;"><span class="lbl">‚Ü≥ Rate adj: ${maDelta > 0 ? '+' : ''}${maDelta} laborer${Math.abs(maDelta) > 1 ? 's' : ''} √ó $${maLR.toFixed(2)}/hr</span><span class="val">${maAdj >= 0 ? '+' : '-'}$${Math.abs(maAdj).toFixed(2)}/hr</span></div>`; } }
            html += `<div class="output-row"><span class="lbl">Shift Hours</span><span class="val">${tier.std.hours.toFixed(1)}</span></div>`;
            html += `<div class="output-row"><span class="lbl">Days</span><span class="val">${tier.std.days}</span></div>`;
            if (tier.std.hustle) {
                html += `<div class="output-row" style="color:#ffaa00;font-size:0.7rem;"><span class="lbl">&#9889; Crew can hustle to stay within shift</span><span class="val"></span></div>`;
            }
            if (travel > 0) {
                html += `<div class="output-row"><span class="lbl">Travel Time</span><span class="val">${travel.toFixed(1)} hrs</span></div>`;
            }
            html += `<div class="output-divider"></div>`;
            html += `<div class="output-row cost"><span class="lbl">Labor & Equip (shift)</span><span class="val">${fmt(tier.std.hours * crewRate)}</span></div>`;
            if (travelCost > 0) {
                html += `<div class="output-row cost"><span class="lbl">Labor & Equip (travel)</span><span class="val">${fmt(travelCost)}</span></div>`;
            }
            html += `<div class="output-row cost"><span class="lbl">Machine Rental (${tier.std.days} day${tier.std.days>1?'s':''})</span><span class="val">${fmt(machineRental)}</span></div>`;
            html += `<div class="output-row cost"><span class="lbl">Material (${boxesNeeded} boxes x ${fmt(boxPrice)})</span><span class="val">${fmt(material)}</span></div>`;
            html += `<div class="output-row highlight"><span class="lbl">Total</span><span class="val">${fmt(tier.std.hours * crewRate + travelCost + machineRental + material)}</span></div>`;
            el.innerHTML = html;

            sumLabor.ma = tier.std.hours * crewRate + travelCost;
            sumMat.ma = material + machineRental;
            hbRows.push({ name: 'Mastic', tier, travel, note: `${boxesNeeded} boxes` });
            snapshot.activities.mastic = { enabled: true, rawProductionHrs: (lf / Math.max(prod, 0.01)) * stdShift, inputs: { lf, crackWidth, crackDepth, phases, travel }, boxCalc: { crossSection, lfPerBox, boxesNeeded }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.mastic, prodPerDay: prod, boxPrice, machinePerDay }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, machineRental, material, total: sumLabor.ma + sumMat.ma } };
        } else {
            renderTierTable('ma_output', null);
        }
    } else { renderTierTable('ma_output', null); }

    // === WHEEL STOPS (differentiated production rates) ===
    if (isOn('en_wheelstop')) {
        const newQty = gv('ws_new');
        const resetQty = gv('ws_reset');
        const removeQty = gv('ws_remove');
        const prodInstall = Math.max(gv('prodWsInstall'), 0.01);
        const prodReset = Math.max(gv('prodWsReset'), 0.01);
        const prodRemoval = Math.max(gv('prodWsRemoval'), 0.01);
        const phases = Math.max(gv('ws_phases'), 1);
        const crew = gv('crewWsInstall');
        const travel = gv('ws_travel');
        const totalQty = newQty + resetQty + removeQty;

        if (totalQty > 0) {
            // Calculate raw production hours per operation type
            const installHrs = newQty > 0 ? (newQty / prodInstall) * stdShift : 0;
            const resetHrs = resetQty > 0 ? (resetQty / prodReset) * stdShift : 0;
            const removalHrs = removeQty > 0 ? (removeQty / prodRemoval) * stdShift : 0;
            const combinedRawHrs = installHrs + resetHrs + removalHrs;

            // Optimize shifts for each tier
            function wsTier(factor) {
                const adjHrs = combinedRawHrs / factor;
                return optimizeShifts(adjHrs, stdShift, maxShift, phases);
            }
            const stdR = wsTier(1.0);
            const consR = wsTier(0.80);
            const aggR = wsTier(1.20);

            const tier = {
                cons: { crew, hours: consR.hours, days: consR.days, hustle: consR.hustle },
                std:  { crew, hours: stdR.hours, days: stdR.days, hustle: stdR.hustle },
                agg:  { crew, hours: aggR.hours, days: aggR.days, hustle: aggR.hustle }
            };

            // Labor fractions based on hours share (not qty share)
            const installFrac = combinedRawHrs > 0 ? installHrs / combinedRawHrs : 0;
            const resetFrac = combinedRawHrs > 0 ? resetHrs / combinedRawHrs : 0;
            const removalFrac = combinedRawHrs > 0 ? removalHrs / combinedRawHrs : 0;

            const wsCrewDelta = crew - BASE_CREW_SIZES.wsInstall;
            const wsLaborerRate = gv('rateLaborerAdj');
            const newLabor = tier.std.hours * installFrac * (gv('rateWsInstall') + wsCrewDelta * wsLaborerRate);
            const resetLabor = tier.std.hours * resetFrac * (gv('rateWsReset') + wsCrewDelta * wsLaborerRate);
            const removeLabor = tier.std.hours * removalFrac * (gv('rateWsRemove') + wsCrewDelta * wsLaborerRate);
            const totalLabor = newLabor + resetLabor + removeLabor;

            const newMat = newQty * gv('matWsNew');
            const resetMat = resetQty * gv('matWsPin');
            const removeMat = removeQty * gv('matWsDispose');
            const totalMatCost = newMat + resetMat + removeMat;

            const blendedRate = totalLabor / tier.std.hours;
            const travelCost = travel * blendedRate;

            renderTierTable('ws_output', tier, blendedRate, totalMatCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.wsInstall));
            sumLabor.ws = totalLabor + travelCost;
            sumMat.ws = totalMatCost;
            hbRows.push({ name: 'Wheel Stops', tier, travel });
            snapshot.activities.wheelStops = { enabled: true, rawProductionHrs: combinedRawHrs, inputs: { newQty, resetQty, removeQty, totalQty, phases, travel }, blendedRate, rates: { crewSize: crew, baseCrewSize: BASE_CREW_SIZES.wsInstall, crewDelta: wsCrewDelta, prodInstall, prodReset, prodRemoval, prodPerDay: totalQty > 0 ? totalQty / (combinedRawHrs / stdShift) : 0 }, perTypeHrs: { installHrs, resetHrs, removalHrs, combinedRawHrs }, tiers: tier, costs: { laborTotal: totalLabor, laborTravel: travelCost, material: totalMatCost, total: sumLabor.ws + sumMat.ws } };
        } else {
            renderTierTable('ws_output', null);
        }
    } else { renderTierTable('ws_output', null); }

    // === SIGNS ===
    if (isOn('en_sign')) {
        const postQty = gv('sg_post');
        const bollQty = gv('sg_bollard');
        const baseCrewRate = gv('rateSign');
        const phases = Math.max(gv('sg_phases'), 1);
        const crew = gv('crewSign');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.sign);
        const travel = gv('sg_travel');
        const prodPost = gv('prodSignPost');
        const prodBoll = Math.max(gv('prodSignBollard'), 0.01);

        const equivQty = postQty + (bollQty * (prodPost / prodBoll));
        const matCost = (postQty * gv('matSignSmall')) + (bollQty * (gv('matSignLarge') + gv('matBollard')));

        if (equivQty > 0) {
            const tier = calcThreeTier(equivQty, prodPost, stdShift, maxShift, phases, crew);
            const travelCost = travel * crewRate;
            renderTierTable('sg_output', tier, crewRate, matCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.sign));
            sumLabor.sg = tier.std.hours * crewRate + travelCost;
            sumMat.sg = matCost;
            hbRows.push({ name: 'Signs', tier, travel });
            snapshot.activities.signs = { enabled: true, rawProductionHrs: (equivQty / Math.max(prodPost, 0.01)) * stdShift, inputs: { postQty, bollQty, equivQty, phases, travel }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.sign, prodPost, prodBoll }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, material: matCost, total: sumLabor.sg + sumMat.sg } };
        } else {
            renderTierTable('sg_output', null);
        }
    } else { renderTierTable('sg_output', null); }

    // === BOLLARD REPLACEMENT ===
    if (isOn('en_bollard')) {
        const qty = gv('bo_qty');
        const baseCrewRate = gv('rateBollard');
        const prod = gv('prodBollard');
        const phases = Math.max(gv('bo_phases'), 1);
        const crew = gv('crewBollard');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.bollard);
        const travel = gv('bo_travel');
        const matCost = qty * gv('matBollard');
        const tier = calcThreeTier(qty, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * crewRate;
        renderTierTable('bo_output', tier, crewRate, matCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.bollard));
        if (tier) {
            sumLabor.bo = tier.std.hours * crewRate + travelCost;
            sumMat.bo = matCost;
            hbRows.push({ name: 'Bollards', tier, travel });
            snapshot.activities.bollards = { enabled: true, rawProductionHrs: (qty / Math.max(prod, 0.01)) * stdShift, inputs: { qty, phases, travel }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.bollard, prodPerDay: prod }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, material: matCost, total: sumLabor.bo + sumMat.bo } };
        }
    } else { renderTierTable('bo_output', null); }

    // === RUBBER SPEED BUMPS ===
    if (isOn('en_speedbump')) {
        const qty = gv('sb_qty');
        const baseCrewRate = gv('rateSpeedBump');
        const prod = gv('prodSpeedBump');
        const phases = Math.max(gv('sb_phases'), 1);
        const crew = gv('crewSpeedBump');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.speedBump);
        const travel = gv('sb_travel');
        const matCost = qty * gv('matSpeedBump');
        const tier = calcThreeTier(qty, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * crewRate;
        renderTierTable('sb_output', tier, crewRate, matCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.speedBump));
        if (tier) {
            sumLabor.sb = tier.std.hours * crewRate + travelCost;
            sumMat.sb = matCost;
            hbRows.push({ name: 'Rubber Speed Bumps', tier, travel });
            snapshot.activities.speedBumps = { enabled: true, rawProductionHrs: (qty / Math.max(prod, 0.01)) * stdShift, inputs: { qty, phases, travel }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.speedBump, prodPerDay: prod }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, material: matCost, total: sumLabor.sb + sumMat.sb } };
        }
    } else { renderTierTable('sb_output', null); }

    // === SPEED HUMPS ===
    if (isOn('en_speedhump')) {
        const qty = gv('sh_qty');
        const baseCrewRate = gv('rateSpeedHump');
        const prod = gv('prodSpeedHump');
        const phases = Math.max(gv('sh_phases'), 1);
        const crew = gv('crewSpeedHump');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.speedHump);
        const travel = gv('sh_travel');
        const tonsPerHump = 2.13;
        const tons = qty > 0 ? Math.ceil(qty * tonsPerHump * wf.sh) : 0;
        const matCost = tons * asphaltPrice;
        sv('sh_tons', tons);
        const tier = calcThreeTier(qty, prod, stdShift, maxShift, phases, crew);
        const travelCost = travel * crewRate;
        renderTierTable('sh_output', tier, crewRate, matCost, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.speedHump));
        if (tier) {
            sumLabor.sh = tier.std.hours * crewRate + travelCost;
            sumMat.sh = matCost;
            hbRows.push({ name: 'Speed Humps', tier, travel });
            snapshot.activities.speedHumps = { enabled: true, rawProductionHrs: (qty / Math.max(prod, 0.01)) * stdShift, inputs: { qty, phases, travel }, tonnage: { tonsPerHump, totalTons: tons }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.speedHump, prodPerDay: prod }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, material: matCost, total: sumLabor.sh + sumMat.sh } };
        }
    } else {
        sv('sh_tons', '0');
        renderTierTable('sh_output', null);
    }

    // === INLET REPAIR ===
    if (isOn('en_inlet')) {
        const repairQty = gv('in_repair');
        const reconQty = gv('in_recon');
        const castingQty = gv('in_casting');
        const baseCrewRate = gv('rateInlet');
        const phases = Math.max(gv('in_phases'), 1);
        const crew = gv('crewInlet');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.inlet);
        const travel = gv('in_travel');

        const repairProd = Math.max(gv('prodInletRepair'), 0.01);
        const hrsPerRecon = gv('prodInletRecon');

        const totalQty = repairQty + reconQty;
        if (totalQty > 0) {
            const repairHrs = repairQty > 0 ? (repairQty / repairProd) * stdShift : 0;
            const reconHrs = reconQty * hrsPerRecon;
            const combinedHrs = repairHrs + reconHrs;

            // Optimize shifts for each tier
            function inletTier(factor) {
                const adjHrs = combinedHrs / factor;
                return optimizeShifts(adjHrs, stdShift, maxShift, phases);
            }
            const stdR = inletTier(1.0);
            const consR = inletTier(0.80);
            const aggR = inletTier(1.20);

            const tier = {
                cons: { crew: crew, hours: consR.hours, days: consR.days, hustle: consR.hustle },
                std:  { crew: crew, hours: stdR.hours, days: stdR.days, hustle: stdR.hustle },
                agg:  { crew: crew, hours: aggR.hours, days: aggR.days, hustle: aggR.hustle }
            };

            const blockCost = totalQty * gv('matBlock');
            const castingCost = castingQty * gv('matCasting');
            const totalMat = blockCost + castingCost;
            const travelCost = travel * crewRate;

            renderTierTable('in_output', tier, crewRate, totalMat, 0, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.inlet));
            sumLabor.in = stdR.hours * crewRate + travelCost;
            sumMat.in = totalMat;
            hbRows.push({ name: 'Inlet Repair', tier, travel });
            snapshot.activities.inletRepair = { enabled: true, rawProductionHrs: combinedHrs, inputs: { repairQty, reconQty, castingQty, phases, travel }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.inlet, repairProd, hrsPerRecon }, combinedRawHrs: combinedHrs, tiers: tier, costs: { laborShift: stdR.hours * crewRate, laborTravel: travelCost, blockCost, castingCost, material: totalMat, total: sumLabor.in + sumMat.in } };
        } else {
            renderTierTable('in_output', null);
        }
    } else { renderTierTable('in_output', null); }

    // === PAINT REMOVAL ===
    if (isOn('en_paintremoval')) {
        const lf = gv('pr_lf');
        const baseCrewRate = gv('rateStriping');
        const prod = gv('prodPaintRemoval');
        const rentalPerDay = gv('matPaintRemoval');
        const phases = Math.max(gv('pr_phases'), 1);
        const crew = gv('crewStriping');
        const crewRate = adjustedRate(baseCrewRate, crew, BASE_CREW_SIZES.striping);
        const travel = gv('pr_travel');

        if (lf > 0) {
            const tier = calcThreeTier(lf, prod, stdShift, maxShift, phases, crew);
            const rental = tier.std.days * rentalPerDay;
            const travelCost = travel * crewRate;

            renderTierTable('pr_output', tier, crewRate, 0, rental, travel, travelCost, crewAdjInfo(crew, BASE_CREW_SIZES.striping));
            sumLabor.pr = tier.std.hours * crewRate + travelCost;
            sumMat.pr = rental;
            hbRows.push({ name: 'Paint Removal', tier, travel, note: 'Grinder rental' });
            snapshot.activities.paintRemoval = { enabled: true, rawProductionHrs: (lf / Math.max(prod, 0.01)) * stdShift, inputs: { lf, phases, travel }, rates: { crewRate, baseCrewRate, crewSize: crew, baseCrewSize: BASE_CREW_SIZES.striping, prodPerDay: prod, rentalPerDay }, tiers: tier, costs: { laborShift: tier.std.hours * crewRate, laborTravel: travelCost, rental, total: sumLabor.pr + sumMat.pr } };
        } else {
            renderTierTable('pr_output', null);
        }
    } else { renderTierTable('pr_output', null); }

    // === ESTIMATE SUMMARY TABLE ===
    const hbBody = document.getElementById('hbBody');
    if (hbRows.length === 0) {
        hbBody.innerHTML = '<tr><td colspan="9" style="text-align:center; color:var(--text-muted); padding:1rem;">Enter quantities above to see estimate data</td></tr>';
    } else {
        let html = '';
        let totConsHrs = 0, totConsDays = 0, totStdHrs = 0, totStdDays = 0, totAggHrs = 0, totAggDays = 0, totTravel = 0;

        hbRows.forEach(row => {
            const { cons, std, agg } = row.tier;
            const tvl = row.travel || 0;
            totConsHrs += cons.hours; totConsDays += cons.days;
            totStdHrs += std.hours; totStdDays += std.days;
            totAggHrs += agg.hours; totAggDays += agg.days;
            totTravel += tvl;

            const hustleFlag = std.hustle ? ' <span style="color:#ffaa00;" title="Crew can hustle">&#9889;</span>' : '';

            html += `<tr>
                <td>${row.name}${row.note ? '<br><span style="font-size:0.6rem;color:var(--text-muted);font-family:IBM Plex Sans,sans-serif;font-weight:400;">' + row.note + '</span>' : ''}</td>
                <td>${std.crew}</td>
                <td class="hb-cons">${cons.hours.toFixed(1)}</td><td class="hb-cons">${cons.days}</td>
                <td class="hb-std">${std.hours.toFixed(1)}${hustleFlag}</td><td class="hb-std">${std.days}</td>
                <td class="hb-agg">${agg.hours.toFixed(1)}</td><td class="hb-agg">${agg.days}</td>
                <td>${tvl > 0 ? tvl.toFixed(1) : '-'}</td>
            </tr>`;
        });

        // Totals row
        html += `<tr style="border-top:2px solid var(--border-highlight); font-weight:700;">
            <td style="color:var(--text-primary);">TOTAL JOB</td>
            <td>-</td>
            <td class="hb-cons">${totConsHrs.toFixed(1)}</td><td class="hb-cons">${totConsDays}</td>
            <td class="hb-std">${totStdHrs.toFixed(1)}</td><td class="hb-std">${totStdDays}</td>
            <td class="hb-agg">${totAggHrs.toFixed(1)}</td><td class="hb-agg">${totAggDays}</td>
            <td>${totTravel > 0 ? totTravel.toFixed(1) : '-'}</td>
        </tr>`;

        hbBody.innerHTML = html;
    }

    // === COMBINED SUMMARY ===
    let totalLabor = 0, totalMat = 0;
    workTypes.forEach(k => {
        sv('sum_' + k, fmt(sumLabor[k]));
        sv('summ_' + k, fmt(sumMat[k]));
        totalLabor += sumLabor[k];
        totalMat += sumMat[k];
        const laborRow = document.getElementById('sum_' + k + '_row');
        const matRow = document.getElementById('summ_' + k + '_row');
        if (laborRow) laborRow.style.display = sumLabor[k] > 0 ? 'flex' : 'none';
        if (matRow) matRow.style.display = sumMat[k] > 0 ? 'flex' : 'none';
    });

    sv('sum_laborTotal', fmt(totalLabor));
    sv('sum_matTotal', fmt(totalMat));

    const directCost = totalLabor + totalMat;
    const markup = gv('markupPercent') || gv('markupPercent2');
    const markupAmt = directCost * (markup / 100);
    sv('directCostTotal', fmt(directCost));
    sv('markupAmount', fmt(markupAmt));
    sv('bidPrice', fmt(directCost + markupAmt));

    // === UNIT COST REASONABLENESS CHECK ===
    unitChecks = [];
    function addCheck(benchKey, qty, totalCost) {
        if (qty > 0 && totalCost > 0 && BENCHMARKS[benchKey]) {
            const b = BENCHMARKS[benchKey];
            const unitCost = totalCost / qty;
            let status, color;
            if (unitCost >= b.p25 && unitCost <= b.p75) {
                status = 'IN RANGE'; color = '#00cc66';
            } else if (unitCost < b.p25) {
                status = unitCost < b.p25 * 0.5 ? 'VERY LOW' : 'LOW';
                color = unitCost < b.p25 * 0.5 ? '#ff4444' : '#ffaa00';
            } else {
                status = unitCost > b.p75 * 2 ? 'VERY HIGH' : 'HIGH';
                color = unitCost > b.p75 * 2 ? '#ff4444' : '#ffaa00';
            }
            unitChecks.push({ name: b.name, benchKey, qty, unit: b.unit, unitCost, totalCost, p25: b.p25, med: b.med, p75: b.p75, status, color });
        }
    }

    // Crack fill
    if (gv('cf_lf') > 0) addCheck('cf', gv('cf_lf'), sumLabor.cf + sumMat.cf);
    // Sealcoat
    if (gv('sc_sf') > 0) addCheck('sc', gv('sc_sf'), sumLabor.sc + sumMat.sc);

    // Striping ‚Äî benchmark each line item individually
    // Labor apportioned by raw hours share: (itemHrs / totalRawHrs) √ó (shiftLabor + travel)
    if (isOn('en_striping') && snapshot.activities.striping?.lineItems?.length > 0) {
        const stSnap = snapshot.activities.striping;
        const totalRawHrs = stSnap.lineItems.reduce((s, li) => s + li.hours, 0);
        const totalLaborPlusTravel = sumLabor.st; // includes shift + travel

        const stBenchMap = [
            { qtyId: 'st_4line',   benchKey: 'st4'  },
            { qtyId: 'st_6line',   benchKey: 'st6'  },
            { qtyId: 'st_12line',  benchKey: 'st12' },
            { qtyId: 'st_24bar',   benchKey: 'st24' },
            { qtyId: 'st_hc',      benchKey: 'stHC' },
            { qtyId: 'st_arrow',   benchKey: 'stAr' },
            { qtyId: 'st_stencil', benchKey: 'stSt' },
            { qtyId: 'st_curb',    benchKey: 'stCb' },
        ];

        stBenchMap.forEach(({ qtyId, benchKey }) => {
            const li = stSnap.lineItems.find(i => i.id === qtyId);
            if (li && li.qty > 0 && totalRawHrs > 0) {
                const laborShare = (li.hours / totalRawHrs) * totalLaborPlusTravel;
                addCheck(benchKey, li.qty, laborShare + li.matCost);
            }
        });
    }

    // Asphalt repair
    if (gv('ar_sf') > 0) addCheck('ar', gv('ar_sf'), sumLabor.ar + sumMat.ar);
    // Mastic
    if (gv('ma_lf') > 0) addCheck('ma', gv('ma_lf'), sumLabor.ma + sumMat.ma);

    // Wheel stops ‚Äî separate benchmarks using differentiated crew rates and material
    if (isOn('en_wheelstop') && snapshot.activities.wheelStops?.enabled) {
        const wsSnap = snapshot.activities.wheelStops;
        const wsI = wsSnap.inputs;
        const wsTier = wsSnap.tiers;
        const wsTravel = wsI.travel;
        if (wsI.totalQty > 0 && wsTier) {
            const stdHrs = wsTier.std.hours;
            // Each type gets its proportional share of shift hours √ó its own crew rate + its own material
            if (wsI.newQty > 0) {
                const frac = wsI.newQty / wsI.totalQty;
                const labor = stdHrs * frac * gv('rateWsInstall');
                const travelCost = wsTravel * gv('rateWsInstall') * frac;
                const mat = wsI.newQty * gv('matWsNew');
                addCheck('ws', wsI.newQty, labor + travelCost + mat);
            }
            if (wsI.resetQty > 0) {
                const frac = wsI.resetQty / wsI.totalQty;
                const labor = stdHrs * frac * gv('rateWsReset');
                const travelCost = wsTravel * gv('rateWsReset') * frac;
                const mat = wsI.resetQty * gv('matWsPin');
                addCheck('ws_r', wsI.resetQty, labor + travelCost + mat);
            }
            if (wsI.removeQty > 0) {
                const frac = wsI.removeQty / wsI.totalQty;
                const labor = stdHrs * frac * gv('rateWsRemove');
                const travelCost = wsTravel * gv('rateWsRemove') * frac;
                const mat = wsI.removeQty * gv('matWsDispose');
                addCheck('ws_rm', wsI.removeQty, labor + travelCost + mat);
            }
        }
    }

    // Signs ‚Äî separate benchmarks for post (small) and bollard (large)
    if (isOn('en_sign') && snapshot.activities.signs?.enabled) {
        const sgSnap = snapshot.activities.signs;
        const postQty = sgSnap.inputs.postQty;
        const bollQty = sgSnap.inputs.bollQty;
        const equivQty = sgSnap.inputs.equivQty;
        if (equivQty > 0) {
            // Apportion by equivalent production share
            const postEquiv = postQty;
            const bollEquiv = equivQty - postQty; // bollards weighted by prod ratio
            if (postQty > 0) addCheck('sg_sm', postQty, (sumLabor.sg + sumMat.sg) * (postEquiv / equivQty));
            if (bollQty > 0) addCheck('sg_lg', bollQty, (sumLabor.sg + sumMat.sg) * (bollEquiv / equivQty));
        }
    }

    // Bollards
    if (gv('bo_qty') > 0) addCheck('bo', gv('bo_qty'), sumLabor.bo + sumMat.bo);
    // Speed bumps
    if (gv('sb_qty') > 0) addCheck('sb', gv('sb_qty'), sumLabor.sb + sumMat.sb);
    // Speed humps
    if (gv('sh_qty') > 0) addCheck('sh', gv('sh_qty'), sumLabor.sh + sumMat.sh);
    // Inlet repair
    if (gv('in_repair') > 0) addCheck('in_r', gv('in_repair'), (sumLabor.in + sumMat.in) * (gv('in_repair') / (gv('in_repair') + gv('in_recon'))));
    // Inlet reconstruction
    if (gv('in_recon') > 0) addCheck('in_c', gv('in_recon'), (sumLabor.in + sumMat.in) * (gv('in_recon') / (gv('in_repair') + gv('in_recon'))));
    // Paint removal
    if (gv('pr_lf') > 0) addCheck('pr', gv('pr_lf'), sumLabor.pr + sumMat.pr);

    // Render unit check table
    const ucSection = document.getElementById('unitCheckSection');
    const ucBody = document.getElementById('unitCheckBody');
    if (unitChecks.length > 0) {
        ucSection.style.display = 'block';
        let ucHtml = '';
        unitChecks.forEach(c => {
            ucHtml += `<tr>
                <td>${c.name}</td>
                <td>${c.qty.toLocaleString()}</td>
                <td>${c.unit}</td>
                <td style="font-weight:700;">$${c.unitCost.toFixed(2)}</td>
                <td>$${c.p25.toFixed(2)}</td>
                <td>$${c.med.toFixed(2)}</td>
                <td>$${c.p75.toFixed(2)}</td>
                <td style="color:${c.color}; font-weight:700;">${c.status}</td>
            </tr>`;
        });
        ucBody.innerHTML = ucHtml;
    } else {
        ucSection.style.display = 'none';
    }

    // === BUILD FINAL SNAPSHOT ===
    snapshot.meta = { version: CALC_VERSION, timestamp: new Date().toISOString(), projectName: document.getElementById('projectName').value || 'Unnamed Project' };
    snapshot.settings = { stdShift, maxShift, asphaltPrice, baseAsphaltPrice, dgaPrice, markupPercent: markup, laborerAdjRate: gv('rateLaborerAdj'), wasteFactors: { cf: wf.cf, sc: wf.sc, st: wf.st, ar: wf.ar, ma: wf.ma, sh: wf.sh } };
    snapshot.summary = { laborByType: { ...sumLabor }, materialByType: { ...sumMat }, totalLabor, totalMat, directCost, markupPercent: markup, markupAmount: markupAmt, bidPrice: directCost + markupAmt };
    snapshot.hbRows = hbRows;
    snapshot.unitChecks = unitChecks;
    // === CREW CLUSTERING ===
    const clusterResults = clusterize(snapshot, stdShift, maxShift);
    snapshot.clustering = clusterResults;

    // === CLUSTER-AWARE UNIT COST RECALCULATION ===
    // When clustering is active, recalculate unit costs using clustered hours
    // for activities that share a crew. This reflects real mobilization cost
    // rather than standalone-shift minimums.
    if (clusterResults) {
        // Map benchmark keys ‚Üí cluster activity keys
        const benchToCluster = {
            cf: 'crackFill', sc: 'sealcoat',
            st4: 'striping', st6: 'striping', st12: 'striping', st24: 'striping',
            stAr: 'striping', stHC: 'striping', stSt: 'striping', stCb: 'striping',
            ar: 'asphaltRepair', ma: 'mastic',
            ws: 'wheelStops', ws_r: 'wheelStops', ws_rm: 'wheelStops',
            sg_sm: 'signs', sg_lg: 'signs',
            bo: 'bollards', sb: 'speedBumps', sh: 'speedHumps',
            in_r: 'inletRepair', in_c: 'inletRepair',
            pr: 'paintRemoval'
        };

        for (let i = 0; i < unitChecks.length; i++) {
            const check = unitChecks[i];
            // Find the benchmark key for this check
            const benchKey = Object.keys(BENCHMARKS).find(k => BENCHMARKS[k].name === check.name);
            if (!benchKey) continue;

            const clusterActKey = benchToCluster[benchKey];
            if (!clusterActKey) continue;

            // Find this activity in the cluster results
            for (const cluster of Object.values(clusterResults)) {
                if (!cluster.clusteringApplied) continue;
                const clusterAct = cluster.activeActivities.find(a => a.actKey === clusterActKey);
                if (!clusterAct) continue;

                // Recalculate labor using apportioned hours √ó activity crew rate
                const clusteredLabor = clusterAct.apportionedHrs * clusterAct.crewRate;
                // Travel: shared once across cluster, proportional to this activity
                const clusteredTravel = cluster.clusterTravel * clusterAct.crewRate * clusterAct.proportion;

                // Total clustered labor+travel for this activity
                const clusteredActivityTotal = clusteredLabor + clusteredTravel;

                // Determine this check's share of the activity's cost
                // For sub-item benchmarks (striping items, ws types, sign types),
                // use the same fraction the addCheck used for standalone
                let matCost = 0;
                let laborCost = clusteredActivityTotal;

                if (benchKey.startsWith('st') && snapshot.activities.striping?.lineItems) {
                    // Striping sub-items: apportion clustered labor by raw hours share
                    const stSnap = snapshot.activities.striping;
                    const totalRawHrs = stSnap.lineItems.reduce((s, li) => s + li.hours, 0);
                    const qtyMap = { st4:'st_4line', st6:'st_6line', st12:'st_12line', st24:'st_24bar', stHC:'st_hc', stAr:'st_arrow', stSt:'st_stencil', stCb:'st_curb' };
                    const li = stSnap.lineItems.find(item => item.id === qtyMap[benchKey]);
                    if (li && totalRawHrs > 0) {
                        laborCost = (li.hours / totalRawHrs) * clusteredActivityTotal;
                        matCost = li.matCost;
                    } else { continue; }
                } else if ((benchKey === 'ws' || benchKey === 'ws_r' || benchKey === 'ws_rm') && snapshot.activities.wheelStops?.inputs) {
                    const wsI = snapshot.activities.wheelStops.inputs;
                    const wsT = wsI.totalQty;
                    const typeQty = benchKey === 'ws' ? wsI.newQty : benchKey === 'ws_r' ? wsI.resetQty : wsI.removeQty;
                    const frac = typeQty / wsT;
                    // Use type-specific crew rate for differentiated cost
                    const typeRate = benchKey === 'ws' ? gv('rateWsInstall') : benchKey === 'ws_r' ? gv('rateWsReset') : gv('rateWsRemove');
                    const typeMatPerUnit = benchKey === 'ws' ? gv('matWsNew') : benchKey === 'ws_r' ? gv('matWsPin') : gv('matWsDispose');
                    // Apportioned hours from cluster √ó type fraction √ó type-specific rate
                    laborCost = clusterAct.apportionedHrs * frac * typeRate + cluster.clusterTravel * clusterAct.proportion * frac * typeRate;
                    matCost = typeQty * typeMatPerUnit;
                } else if ((benchKey === 'sg_sm' || benchKey === 'sg_lg') && snapshot.activities.signs?.inputs) {
                    const sgI = snapshot.activities.signs.inputs;
                    const frac = benchKey === 'sg_sm' ? sgI.postQty / sgI.equivQty : (sgI.equivQty - sgI.postQty) / sgI.equivQty;
                    laborCost = frac * clusteredActivityTotal;
                    matCost = frac * sumMat.sg;
                } else if (benchKey === 'in_r' || benchKey === 'in_c') {
                    const repQ = gv('in_repair'), recQ = gv('in_recon');
                    const frac = benchKey === 'in_r' ? repQ/(repQ+recQ) : recQ/(repQ+recQ);
                    laborCost = frac * clusteredActivityTotal;
                    matCost = frac * sumMat.in;
                } else {
                    // Full-activity benchmarks (cf, sc, ar, ma, bo, sb, sh, pr)
                    const matKeyMap = { cf:'cf', sc:'sc', ar:'ar', ma:'ma', bo:'bo', sb:'sb', sh:'sh', pr:'pr' };
                    matCost = sumMat[matKeyMap[benchKey]] || 0;
                }

                const clusteredTotalCost = laborCost + matCost;
                const clusteredUnitCost = clusteredTotalCost / check.qty;

                // Recalculate status
                const b = BENCHMARKS[benchKey];
                let status, color;
                if (clusteredUnitCost >= b.p25 && clusteredUnitCost <= b.p75) {
                    status = 'IN RANGE'; color = '#00cc66';
                } else if (clusteredUnitCost < b.p25) {
                    status = clusteredUnitCost < b.p25 * 0.5 ? 'VERY LOW' : 'LOW';
                    color = clusteredUnitCost < b.p25 * 0.5 ? '#ff4444' : '#ffaa00';
                } else {
                    status = clusteredUnitCost > b.p75 * 2 ? 'VERY HIGH' : 'HIGH';
                    color = clusteredUnitCost > b.p75 * 2 ? '#ff4444' : '#ffaa00';
                }

                // Update the unit check with clustered values
                unitChecks[i] = { ...check, unitCost: clusteredUnitCost, status, color, clustered: true, standaloneUnitCost: check.unitCost };
                break;
            }
        }

        // Re-render unit check table with updated values
        const ucBody2 = document.getElementById('unitCheckBody');
        if (ucBody2 && unitChecks.length > 0) {
            let ucHtml2 = '';
            unitChecks.forEach(c => {
                ucHtml2 += `<tr>
                    <td>${c.name}${c.clustered ? ' <span style="font-size:0.7rem;color:var(--accent-cyan);">‚ö°clustered</span>' : ''}</td>
                    <td>${c.qty.toLocaleString()}</td>
                    <td>${c.unit}</td>
                    <td style="font-weight:700;">$${c.unitCost.toFixed(2)}</td>
                    <td>$${c.p25.toFixed(2)}</td>
                    <td>$${c.med.toFixed(2)}</td>
                    <td>$${c.p75.toFixed(2)}</td>
                    <td style="color:${c.color};font-weight:700;letter-spacing:0.5px;">${c.status}</td>
                </tr>`;
            });
            ucBody2.innerHTML = ucHtml2;
        }

        // Update snapshot with cluster-adjusted unit checks
        snapshot.unitChecks = unitChecks;
    }

    // === UNIT COST COLUMN IN COST SUMMARY ===
    renderUnitCostColumn(unitChecks);

    snapshot.notes = collectNotes();
    snapshot.scopeAssumptions = collectAssumptions();
    window.lastCalcSnapshot = snapshot;

    // === RENDER CLUSTER DEPLOYMENT SUMMARY ===
    renderClusterSummary(clusterResults);

    // === ESTIMATE CONFIDENCE ===
    const confidence = calculateConfidence(snapshot);
    snapshot.confidence = confidence;
    renderConfidence(confidence);

    // === CALENDAR DURATION ===
    const calendar = calculateCalendarDuration(snapshot);
    snapshot.calendar = calendar;
    renderCalendar(calendar);

    // === RENDER JOB ANALYSIS ===
    renderAnalysis();

    checkAsphaltPrices();
}

// ===== UNIT COST COLUMN IN COST SUMMARY =====
function renderUnitCostColumn(unitChecks) {
    const col = document.getElementById('unitCostColumn');
    const body = document.getElementById('unitCostColumnBody');
    if (!col || !body) return;
    if (!unitChecks || unitChecks.length === 0) {
        col.style.display = 'none';
        return;
    }
    col.style.display = '';
    let html = '';
    unitChecks.forEach(c => {
        const badgeClass = c.status.replace(/\s+/g, '-').toLowerCase();
        html += `<div class="unit-cost-row">
            <span class="lbl">${c.name}${c.clustered ? ' ‚ö°' : ''}</span>
            <span class="val">$${c.unitCost.toFixed(2)}/${c.unit}</span>
            <span class="unit-cost-badge ${badgeClass}">${c.status}</span>
        </div>`;
    });
    body.innerHTML = html;
}

// ===== ESTIMATE CONFIDENCE =====
function calculateConfidence(snap) {
    const acts = snap.activities || {};
    const checks = snap.unitChecks || [];
    const activeActs = Object.entries(acts).filter(([, a]) => a && a.enabled);
    if (activeActs.length === 0) return null;

    const actNames = {
        crackFill: 'Crack Fill', sealcoat: 'Sealcoat', striping: 'Striping',
        asphaltRepair: 'Asphalt Repair', mastic: 'Mastic', wheelStops: 'Wheel Stops',
        signs: 'Signs', bollards: 'Bollards', speedBumps: 'Speed Bumps',
        speedHumps: 'Speed Humps', inletRepair: 'Inlet Repair', paintRemoval: 'Paint Removal'
    };

    // 1. Production Reliability (35%) ‚Äî weighted avg of BAND_SCORE by direct cost share
    let totalDirectCost = 0;
    let weightedBandScore = 0;
    const prodDrivers = [];
    activeActs.forEach(([key, act]) => {
        const cost = act.costs?.total || 0;
        totalDirectCost += cost;
        const conf = RATE_CONFIDENCE[key];
        const bandScore = conf ? (BAND_SCORE[conf.band] || 0.70) : 0.70;
        weightedBandScore += bandScore * cost;
        prodDrivers.push({ name: actNames[key] || key, band: conf?.label || '?', bandScore, cost, reliability: conf?.reliability || '' });
    });
    const prodReliability = totalDirectCost > 0 ? weightedBandScore / totalDirectCost : 0.70;
    // Sort drivers by cost share descending so the biggest cost-impact items show first
    prodDrivers.sort((a, b) => b.cost - a.cost);

    // 2. Benchmark Alignment (30%) ‚Äî % of unit checks IN RANGE
    const totalChecks = checks.length;
    const inRange = checks.filter(c => c.status === 'IN RANGE').length;
    const benchAlignment = totalChecks > 0 ? inRange / totalChecks : 0.50;
    const benchOutliers = checks.filter(c => c.status !== 'IN RANGE').map(c => ({
        name: c.name, status: c.status, unitCost: c.unitCost, unit: c.unit, p25: c.p25, p75: c.p75
    }));

    // 3. Scope Definition (20%) ‚Äî % of active activities with qty in QTY_RANGES normal band
    const actToBenchKeys = {
        crackFill: ['cf'], sealcoat: ['sc'], striping: ['st4','st6','st12','st24','stAr','stHC','stSt','stCb'],
        asphaltRepair: ['ar'], mastic: ['ma'], wheelStops: ['ws','ws_r','ws_rm'],
        signs: ['sg_sm','sg_lg'], bollards: ['bo'], speedBumps: ['sb'], speedHumps: ['sh'],
        inletRepair: ['in_r','in_c'], paintRemoval: ['pr']
    };
    let scopeChecked = 0, scopeInRange = 0;
    const scopeDrivers = [];
    activeActs.forEach(([key]) => {
        const bKeys = actToBenchKeys[key] || [];
        bKeys.forEach(bk => {
            const qr = QTY_RANGES[bk];
            const check = checks.find(c => c.benchKey === bk);
            if (qr && check) {
                scopeChecked++;
                const inBand = check.qty >= qr.low && check.qty <= qr.high;
                if (inBand) scopeInRange++;
                if (!inBand) {
                    const dir = check.qty < qr.low ? 'below' : 'above';
                    scopeDrivers.push({ name: check.name, qty: check.qty, unit: check.unit, low: qr.low, high: qr.high, dir });
                }
            }
        });
    });
    const scopeDefinition = scopeChecked > 0 ? scopeInRange / scopeChecked : 0.50;

    // 4. Data Quality (15%) ‚Äî weighted avg of sample-size scores
    let dqWeightedScore = 0, dqTotalCost = 0;
    const dqDrivers = [];
    checks.forEach(c => {
        const b = BENCHMARKS[c.benchKey];
        if (!b) return;
        const n = b.n || 0;
        let nScore, tier;
        if (n >= 30) { nScore = 1.0; tier = 'strong'; }
        else if (n >= 15) { nScore = 0.80; tier = 'good'; }
        else if (n >= 5) { nScore = 0.60; tier = 'limited'; }
        else if (n > 0) { nScore = 0.40; tier = 'sparse'; }
        else { nScore = 0.20; tier = 'derived'; }
        const cost = c.totalCost || (c.unitCost * c.qty) || 0;
        dqWeightedScore += nScore * cost;
        dqTotalCost += cost;
        dqDrivers.push({ name: c.name, n, tier, nScore, cost });
    });
    const dataQuality = dqTotalCost > 0 ? dqWeightedScore / dqTotalCost : 0.20;
    // Sort by cost descending
    dqDrivers.sort((a, b) => b.cost - a.cost);

    // Composite
    const composite = prodReliability * 0.35 + benchAlignment * 0.30 + scopeDefinition * 0.20 + dataQuality * 0.15;
    let descriptor, color;
    if (composite >= 0.80) { descriptor = 'HIGH'; color = 'var(--accent-green)'; }
    else if (composite >= 0.65) { descriptor = 'MODERATE-HIGH'; color = 'var(--accent-cyan)'; }
    else if (composite >= 0.50) { descriptor = 'MODERATE'; color = '#ffaa00'; }
    else { descriptor = 'LOW'; color = '#ff4444'; }

    return {
        prodReliability, benchAlignment, scopeDefinition, dataQuality,
        composite, descriptor, color,
        details: { totalChecks, inRange, scopeChecked, scopeInRange, activeCount: activeActs.length },
        explain: { prodDrivers, benchOutliers, scopeDrivers, dqDrivers, totalDirectCost }
    };
}

function renderConfidence(result) {
    const section = document.getElementById('confidenceSection');
    const body = document.getElementById('confidenceBody');
    if (!section || !body) { if (section) section.style.display = 'none'; return; }
    if (!result) { section.style.display = 'none'; return; }
    section.style.display = '';

    function barColor(val) {
        if (val >= 0.80) return 'var(--accent-green)';
        if (val >= 0.65) return 'var(--accent-cyan)';
        if (val >= 0.50) return '#ffaa00';
        return '#ff4444';
    }
    function driverTag(score) {
        if (score >= 0.85) return 'good';
        if (score >= 0.70) return 'mid';
        if (score >= 0.50) return 'warn';
        return 'low';
    }
    function barRow(label, value) {
        const pct = (value * 100).toFixed(0);
        return `<div class="confidence-bar-row">
            <span class="label">${label}</span>
            <div class="confidence-bar-track">
                <div class="confidence-bar-fill" style="width:${pct}%; background:${barColor(value)};"></div>
            </div>
            <span class="confidence-bar-value" style="color:${barColor(value)};">${pct}%</span>
        </div>`;
    }

    const ex = result.explain;
    let html = '<div class="confidence-section">';

    // --- Production Reliability ---
    html += barRow('Production Reliability (35%)', result.prodReliability);
    html += '<div class="confidence-explain">';
    html += '<div class="definition">How predictable are the production rates? Cost-weighted average of field variance bands (¬±10% to ¬±40%) across active work types.</div>';
    ex.prodDrivers.forEach(d => {
        const costPct = result.explain.totalDirectCost > 0 ? ((d.cost / result.explain.totalDirectCost) * 100).toFixed(0) : 0;
        html += `<div class="driver"><span class="driver-tag ${driverTag(d.bandScore)}">${d.band}</span> <span>${d.name} (${costPct}% of cost) ‚Äî ${d.reliability}</span></div>`;
    });
    html += '</div>';

    // --- Benchmark Alignment ---
    html += barRow('Benchmark Alignment (30%)', result.benchAlignment);
    html += '<div class="confidence-explain">';
    html += `<div class="definition">What percentage of calculated unit costs fall within the P25-P75 range from 347 historical jobs? ${result.details.inRange} of ${result.details.totalChecks} line items are IN RANGE.</div>`;
    if (ex.benchOutliers.length > 0) {
        html += '<div style="margin-top:0.15rem;">';
        ex.benchOutliers.forEach(o => {
            const tag = (o.status.includes('VERY') ? 'low' : 'warn');
            html += `<div class="driver"><span class="driver-tag ${tag}">${o.status}</span> <span>${o.name}: $${o.unitCost.toFixed(2)}/${o.unit} (range $${o.p25.toFixed(2)}-$${o.p75.toFixed(2)})</span></div>`;
        });
        html += '</div>';
    } else {
        html += '<div class="driver"><span class="driver-tag good">‚úì</span> <span>All line items within historical P25-P75 range</span></div>';
    }
    html += '</div>';

    // --- Scope Definition ---
    html += barRow('Scope Definition (20%)', result.scopeDefinition);
    html += '<div class="confidence-explain">';
    html += `<div class="definition">Are the entered quantities within typical job-size ranges? ${result.details.scopeInRange} of ${result.details.scopeChecked} line items fall within the normal quantity band.</div>`;
    if (ex.scopeDrivers.length > 0) {
        ex.scopeDrivers.forEach(s => {
            const tag = 'warn';
            html += `<div class="driver"><span class="driver-tag ${tag}">${s.dir.toUpperCase()}</span> <span>${s.name}: ${s.qty.toLocaleString()} ${s.unit} (typical range: ${s.low.toLocaleString()}-${s.high.toLocaleString()})</span></div>`;
        });
    } else {
        html += '<div class="driver"><span class="driver-tag good">‚úì</span> <span>All quantities within typical job-size ranges</span></div>';
    }
    html += '</div>';

    // --- Data Quality ---
    html += barRow('Data Quality (15%)', result.dataQuality);
    html += '<div class="confidence-explain">';
    html += '<div class="definition">How robust is the benchmark data behind each unit cost? Based on historical sample sizes weighted by cost share. n‚â•30 = strong, n‚â•15 = good, n‚â•5 = limited, n>0 = sparse, n=0 = derived (no field data).</div>';
    const dqTotal = ex.dqDrivers.reduce((s, d) => s + d.cost, 0);
    ex.dqDrivers.forEach(d => {
        const tag = d.tier === 'strong' ? 'good' : d.tier === 'good' ? 'good' : d.tier === 'limited' ? 'mid' : d.tier === 'sparse' ? 'warn' : 'low';
        const costPct = dqTotal > 0 ? ((d.cost / dqTotal) * 100).toFixed(0) : 0;
        html += `<div class="driver"><span class="driver-tag ${tag}">n=${d.n}</span> <span>${d.name} ‚Äî ${d.tier} (${costPct}% of cost)</span></div>`;
    });
    html += '</div>';

    html += '</div>';

    const pct = (result.composite * 100).toFixed(0);
    html += `<div class="confidence-composite">
        <span class="score" style="color:${result.color};">${pct}%</span>
        <div>
            <div class="descriptor" style="color:${result.color};">${result.descriptor} CONFIDENCE</div>
            <div class="detail">${result.details.inRange}/${result.details.totalChecks} activities in benchmark range ¬∑ ${result.details.activeCount} work types active</div>
        </div>
    </div>`;

    body.innerHTML = html;
}

// ===== CALENDAR DURATION =====
function calculateCalendarDuration(snap) {
    const acts = snap.activities || {};
    const clustering = snap.clustering;
    const activeKeys = Object.keys(acts).filter(k => acts[k] && acts[k].enabled);
    if (activeKeys.length === 0) return null;

    // Build timeline entries from clusters
    const timeline = [];
    const actDisplayNames = {
        asphaltRepair: 'Asphalt Repair', wheelStops: 'Wheel Stops', bollards: 'Bollards',
        signs: 'Signs', inletRepair: 'Inlet Repair', speedHumps: 'Speed Humps',
        striping: 'Striping', paintRemoval: 'Paint Removal', speedBumps: 'Speed Bumps',
        sealcoat: 'Sealcoating', crackFill: 'Crack Filling', mastic: 'Mastic'
    };

    // Group active activities by cluster
    const clusterEntries = [];
    if (clustering) {
        Object.values(clustering).forEach(cluster => {
            if (!cluster.activeActivities || cluster.activeActivities.length === 0) return;
            // Find earliest work sequence position for this cluster
            const earliestPos = Math.min(...cluster.activeActivities.map(a =>
                WORK_SEQUENCE.indexOf(a.actKey) >= 0 ? WORK_SEQUENCE.indexOf(a.actKey) : 999
            ));
            const names = cluster.activeActivities.map(a => actDisplayNames[a.actKey] || a.actKey).join(' + ');
            const maxCrew = Math.max(...cluster.activeActivities.map(a => a.crewSize));
            const days = cluster.clusteringApplied ? Math.ceil(cluster.clusterTotalHrs / snap.settings.stdShift) : (acts[cluster.activeActivities[0].actKey]?.tiers?.std?.days || 1);
            const hours = cluster.clusteringApplied ? cluster.clusterTotalHrs : (acts[cluster.activeActivities[0].actKey]?.tiers?.std?.hours || snap.settings.stdShift);
            const actKeys = cluster.activeActivities.map(a => a.actKey);
            clusterEntries.push({ name: cluster.name + ': ' + names, days, hours, crew: maxCrew, position: earliestPos, actKeys, icon: cluster.icon });
        });
    } else {
        // No clustering ‚Äî each activity is standalone
        activeKeys.forEach(key => {
            const act = acts[key];
            if (!act.tiers) return;
            const pos = WORK_SEQUENCE.indexOf(key) >= 0 ? WORK_SEQUENCE.indexOf(key) : 999;
            clusterEntries.push({
                name: actDisplayNames[key] || key,
                days: act.tiers.std.days,
                hours: act.tiers.std.hours,
                crew: act.rates?.crewSize || 1,
                position: pos,
                actKeys: [key],
                icon: ''
            });
        });
    }

    // Sort by work sequence position
    clusterEntries.sort((a, b) => a.position - b.position);

    // Build timeline with cure windows
    let currentDay = 1;
    for (let i = 0; i < clusterEntries.length; i++) {
        const entry = clusterEntries[i];

        // Check if a cure window is needed before this entry.
        // Scan ALL prior cluster entries, not just the immediately preceding one,
        // because a dependent activity (e.g. sealcoat) may be separated from its
        // prerequisite (e.g. crackFill) by an unrelated cluster (e.g. mastic).
        if (i > 0) {
            const curKeys = entry.actKeys;
            let maxCure = 0;
            for (let j = 0; j < i; j++) {
                const prevKeys = clusterEntries[j].actKeys;
                for (const [cureKey, cureDays] of Object.entries(CURE_WINDOWS)) {
                    const [before, , after] = cureKey.split('_');
                    if (prevKeys.includes(before) && curKeys.includes(after)) {
                        maxCure = Math.max(maxCure, cureDays);
                    }
                }
            }
            if (maxCure > 0) {
                timeline.push({ type: 'cure', startDay: currentDay, endDay: currentDay + maxCure - 1, days: maxCure, name: 'Cure Window' });
                currentDay += maxCure;
            }
        }

        timeline.push({
            type: 'work',
            startDay: currentDay,
            endDay: currentDay + entry.days - 1,
            days: entry.days,
            name: entry.name,
            crew: entry.crew,
            hours: entry.hours,
            icon: entry.icon
        });
        currentDay += entry.days;
    }

    // Weather contingency
    const weatherDays = Math.max(parseInt(document.getElementById('weatherDays')?.value) || 0, 0);
    if (weatherDays > 0) {
        timeline.push({ type: 'weather', startDay: currentDay, endDay: currentDay + weatherDays - 1, days: weatherDays, name: 'Weather Contingency' });
        currentDay += weatherDays;
    }

    const totalDays = currentDay - 1;
    const workDays = timeline.filter(t => t.type === 'work').reduce((s, t) => s + t.days, 0);
    const cureDays = timeline.filter(t => t.type === 'cure').reduce((s, t) => s + t.days, 0);

    return { timeline, totalDays, workDays, cureDays, weatherDays };
}

function renderCalendar(result) {
    const section = document.getElementById('calendarSection');
    const body = document.getElementById('calendarBody');
    if (!section || !body) { if (section) section.style.display = 'none'; return; }
    if (!result || result.timeline.length === 0) { section.style.display = 'none'; return; }
    section.style.display = '';

    let html = '<div class="timeline-row header-row"><span>Days</span><span>Activity</span><span class="crew-col">Crew</span><span class="hours-col">Hours</span></div>';

    result.timeline.forEach(entry => {
        const dayLabel = entry.days === 1 ? `Day ${entry.startDay}` : `Day ${entry.startDay}-${entry.endDay}`;
        if (entry.type === 'cure') {
            html += `<div class="timeline-row cure-row">
                <span class="day-range">${dayLabel}</span>
                <span class="activity-name">‚è≥ ${entry.name}</span>
                <span class="crew-col">-</span>
                <span class="hours-col">-</span>
            </div>`;
        } else if (entry.type === 'weather') {
            html += `<div class="timeline-row cure-row">
                <span class="day-range">${dayLabel}</span>
                <span class="activity-name">üåßÔ∏è ${entry.name}</span>
                <span class="crew-col">-</span>
                <span class="hours-col">-</span>
            </div>`;
        } else {
            html += `<div class="timeline-row">
                <span class="day-range">${dayLabel}</span>
                <span class="activity-name">${entry.icon ? entry.icon + ' ' : ''}${entry.name}</span>
                <span class="crew-col">${entry.crew}-man</span>
                <span class="hours-col">${entry.hours.toFixed(1)}h</span>
            </div>`;
        }
    });

    html += `<div class="timeline-total">
        <span>Total: ${result.totalDays} calendar days (${result.workDays} work + ${result.cureDays} cure + ${result.weatherDays} weather)</span>
    </div>`;

    body.innerHTML = html;
}

// ===== CLUSTER DEPLOYMENT SUMMARY =====
function renderClusterSummary(clusterResults) {
    const section = document.getElementById('clusterSection');
    const body = document.getElementById('clusterBody');
    if (!section || !body) return;

    if (!clusterResults) {
        section.style.display = 'none';
        return;
    }

    const clusters = Object.values(clusterResults);
    const hasActiveCluster = clusters.some(c => c.activeActivities && c.activeActivities.length > 0);
    if (!hasActiveCluster) {
        section.style.display = 'none';
        return;
    }

    section.style.display = 'block';

    // Activity display names
    const actDisplayNames = {
        asphaltRepair: 'Asphalt Repair', wheelStops: 'Wheel Stops', bollards: 'Bollards',
        signs: 'Signs', inletRepair: 'Inlet Repair', speedHumps: 'Speed Humps',
        striping: 'Striping', paintRemoval: 'Paint Removal', speedBumps: 'Speed Bumps',
        sealcoat: 'Sealcoating', crackFill: 'Crack Filling', mastic: 'Mastic'
    };

    // Cluster colors
    const clusterColors = {
        heavy: '#e67e22', paint: '#42a5f5', sealcoat: '#66bb6a',
        crackFill: '#ab47bc', mastic: '#ef5350'
    };

    let html = '';
    let totalClusteredHrs = 0, totalStandaloneHrs = 0, physicalCrews = 0;

    clusters.forEach(cluster => {
        if (!cluster.activeActivities || cluster.activeActivities.length === 0) return;

        physicalCrews++;
        const color = clusterColors[cluster.id] || '#9ca8bc';
        const maxCrew = Math.max(...cluster.activeActivities.map(a => a.crewSize));

        html += `<div style="background:var(--bg-primary); border:1px solid var(--border-color); border-left:3px solid ${color}; border-radius:6px; padding:1rem; margin-bottom:0.75rem;">`;
        html += `<div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:0.5rem;">`;
        html += `<span style="font-weight:700; font-size:0.85rem; color:${color};">${cluster.icon} ${cluster.name}</span>`;
        html += `<span style="font-size:0.7rem; color:var(--text-muted);">${maxCrew}-man crew | ${cluster.description}</span>`;
        html += `</div>`;

        if (cluster.clusteringApplied) {
            // Multi-activity cluster with shared mobilization
            html += `<table style="width:100%; border-collapse:collapse; font-size:0.78rem;">`;
            html += `<thead><tr style="border-bottom:1px solid var(--border-color);">`;
            html += `<th style="text-align:left; padding:0.3rem 0.4rem; font-size:0.65rem; color:var(--text-muted); text-transform:uppercase;">Activity</th>`;
            html += `<th style="text-align:center; padding:0.3rem 0.4rem; font-size:0.65rem; color:var(--text-muted); text-transform:uppercase;">Hours</th>`;
            html += `<th style="text-align:center; padding:0.3rem 0.4rem; font-size:0.65rem; color:var(--text-muted); text-transform:uppercase;">Share</th>`;
            html += `</tr></thead><tbody>`;

            cluster.activeActivities.forEach(act => {
                const name = actDisplayNames[act.actKey] || act.actKey;
                html += `<tr style="border-bottom:1px solid var(--border-color);">`;
                html += `<td style="padding:0.3rem 0.4rem; font-weight:500;">${name}</td>`;
                html += `<td style="text-align:center; padding:0.3rem 0.4rem; font-family:'JetBrains Mono',monospace;">${act.apportionedHrs.toFixed(1)}h</td>`;
                html += `<td style="text-align:center; padding:0.3rem 0.4rem; font-family:'JetBrains Mono',monospace; color:var(--text-muted);">${(act.proportion * 100).toFixed(0)}%</td>`;
                html += `</tr>`;
            });

            html += `<tr style="border-top:2px solid var(--border-highlight); font-weight:700;">`;
            html += `<td style="padding:0.3rem 0.4rem; color:${color};">Cluster Total</td>`;
            html += `<td style="text-align:center; padding:0.3rem 0.4rem; font-family:'JetBrains Mono',monospace; color:${color};">${cluster.clusterTotalHrs.toFixed(1)}h</td>`;
            html += `<td style="text-align:center; padding:0.3rem 0.4rem; font-family:'JetBrains Mono',monospace;">${cluster.clusterSnapped.days}d</td>`;
            html += `</tr>`;
            html += `</tbody></table>`;

            if (cluster.hoursSaved > 0) {
                html += `<div style="margin-top:0.5rem; font-size:0.72rem; color:var(--accent-green); font-weight:600;">`;
                html += `Saves ${cluster.hoursSaved.toFixed(1)}h vs standalone (${cluster.standaloneTotal.toFixed(1)}h -> ${cluster.clusterTotalHrs.toFixed(1)}h)`;
                html += `</div>`;
            }

            if (cluster.clusterTravel > 0) {
                html += `<div style="font-size:0.68rem; color:var(--text-muted); margin-top:0.25rem;">Travel: ${cluster.clusterTravel.toFixed(1)}h (shared, max of cluster activities)</div>`;
            }

            totalClusteredHrs += cluster.clusterTotalHrs;
            totalStandaloneHrs += cluster.standaloneTotal;
        } else {
            // Single activity cluster - passthrough
            const act = cluster.activeActivities[0];
            const name = actDisplayNames[act.actKey] || act.actKey;
            html += `<div style="font-size:0.78rem; padding:0.3rem 0; font-family:'JetBrains Mono',monospace;">`;
            html += `${name}: ${act.apportionedHrs.toFixed(1)}h / ${act.apportionedDays}d`;
            html += `</div>`;

            totalClusteredHrs += act.apportionedHrs;
            totalStandaloneHrs += act.apportionedHrs;
        }

        html += `</div>`;
    });

    // Job totals
    const hoursSaved = totalStandaloneHrs - totalClusteredHrs;
    html += `<div style="background:var(--bg-tertiary); border:1px solid var(--border-highlight); border-radius:8px; padding:1rem; margin-top:0.75rem;">`;
    html += `<div style="font-size:0.85rem; font-weight:700; color:var(--text-primary); margin-bottom:0.5rem;">JOB TOTALS</div>`;
    html += `<div style="display:grid; grid-template-columns: repeat(auto-fit, minmax(180px, 1fr)); gap:0.5rem; font-size:0.78rem;">`;
    html += `<div><span style="color:var(--text-muted);">Physical crews:</span> <span style="font-family:'JetBrains Mono',monospace; font-weight:600;">${physicalCrews}</span></div>`;
    html += `<div><span style="color:var(--text-muted);">Clustered hours:</span> <span style="font-family:'JetBrains Mono',monospace; font-weight:600; color:var(--accent-cyan);">${totalClusteredHrs.toFixed(1)}h</span></div>`;
    html += `<div><span style="color:var(--text-muted);">Standalone hours:</span> <span style="font-family:'JetBrains Mono',monospace; font-weight:600;">${totalStandaloneHrs.toFixed(1)}h</span></div>`;
    if (hoursSaved > 0) {
        html += `<div><span style="color:var(--text-muted);">Hours saved:</span> <span style="font-family:'JetBrains Mono',monospace; font-weight:700; color:var(--accent-green);">${hoursSaved.toFixed(1)}h</span></div>`;
    }
    html += `</div></div>`;

    body.innerHTML = html;
}

// ===== SAVE / LOAD / RESET =====
function saveRates() {
    const ids = [
        'hoursPerDay','maxShift','asphaltPrice','baseAsphaltPrice','dgaPrice','markupPercent',
        'rateLaborerAdj',
        'rateCrackFill','rateSealcoat','rateStriping','rateAsphaltSmall','rateAsphaltLarge',
        'rateWsInstall','rateWsReset','rateWsRemove','rateSpeedBump','rateBollard','rateSign',
        'rateMastic','rateInlet','rateSpeedHump',
        'matCrackFill','matSealcoat','mat4Line','mat6Line','mat12Line','mat24Line',
        'matArrow','matHC','matStencil','matCurb','matWsNew','matWsPin','matWsDispose',
        'matSpeedBump','matBollard','matSignSmall','matSignLarge','matMasticBox','matMasticMachine',
        'matBlock','matCasting','matPaintRemoval',
        'prodCrackFill','prodSealcoat','prod4Line','prod6Line','prod12Line','prod24Bar',
        'prodHC','prodArrow','prodStencil','prodCurb','prodAsphaltRepair','prodWsInstall','prodWsReset','prodWsRemoval',
        'prodSpeedBump','prodBollard','prodSignPost','prodSignBollard','prodMastic',
        'prodInletRepair','prodInletRecon','prodSpeedHump','prodPaintRemoval',
        'crewCrackFill','crewSealcoat','crewStriping','crewAsphaltSmall','crewAsphaltLarge',
        'crewWsInstall','crewSpeedBump','crewBollard','crewSign','crewMastic','crewInlet','crewSpeedHump',
        'wasteCrackFill','wasteSealcoat','wasteStriping','wasteAsphalt','wasteMastic','wasteSpeedHump',
        'clusterMode','weatherDays','sc_method'
    ];
    const data = { _version: CALC_VERSION };
    ids.forEach(id => {
        const el = document.getElementById(id);
        if (el) data[id] = el.value;
    });
    // Persist scope checklist states and notes
    SCOPE_ITEMS.forEach(item => {
        const radio = document.querySelector(`input[name="scope_${item.id}"]:checked`);
        if (radio) data['scope_' + item.id] = radio.value;
        const noteEl = document.getElementById('scope_note_' + item.id);
        if (noteEl && noteEl.value.trim()) data['scope_note_' + item.id] = noteEl.value.trim();
    });
    localStorage.setItem('maintCalcRates', JSON.stringify(data));
    showToast('Rates saved locally!');
}

function loadRates() {
    const saved = localStorage.getItem('maintCalcRates');
    if (saved) {
        const data = JSON.parse(saved);
        Object.keys(data).forEach(key => {
            if (key === '_version') return;
            // Scope radio states
            if (key.startsWith('scope_') && !key.startsWith('scope_note_')) {
                const radio = document.getElementById(key + '_' + data[key]);
                if (radio) radio.checked = true;
                return;
            }
            // Scope notes
            if (key.startsWith('scope_note_')) {
                const el = document.getElementById(key);
                if (el) el.value = data[key];
                return;
            }
            const el = document.getElementById(key);
            if (el) el.value = data[key];
        });
        // Update sealcoat method note to match loaded selection
        const scNote = document.getElementById('sc_methodNote');
        const scCfg = SEALCOAT_METHODS[document.getElementById('sc_method').value];
        if (scNote && scCfg) scNote.textContent = scCfg.note;
        showToast('Rates loaded!');
        calculateAll();
    } else {
        showToast('No saved rates found');
    }
}

function clearSavedRates() {
    localStorage.removeItem('maintCalcRates');
    showToast('Saved rates cleared');
}

function resetForm() {
    const quantityInputs = [
        'cf_lf','sc_sf',
        'st_4line','st_6line','st_12line','st_24bar','st_hc','st_arrow','st_stencil','st_curb',
        'ar_sf','ma_lf',
        'ws_new','ws_reset','ws_remove',
        'sg_post','sg_bollard',
        'bo_qty','sb_qty','sh_qty',
        'in_repair','in_recon','in_casting',
        'pr_lf'
    ];
    const phaseInputs = [
        'cf_phases','sc_phases','st_phases','ar_phases','ma_phases',
        'ws_phases','sg_phases','bo_phases','sb_phases','sh_phases','in_phases','pr_phases'
    ];
    const travelInputs = [
        'cf_travel','sc_travel','st_travel','ar_travel','ma_travel',
        'ws_travel','sg_travel','bo_travel','sb_travel','sh_travel','in_travel','pr_travel'
    ];
    quantityInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '';
    });
    phaseInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '1';
    });
    travelInputs.forEach(id => {
        const el = document.getElementById(id);
        if (el) el.value = '0';
    });
    document.getElementById('projectName').value = '';
    document.getElementById('ar_depth').selectedIndex = 0;
    document.getElementById('sc_method').value = 'sprayRig';
    applySealcoatMethod();
    document.getElementById('ma_width').value = '1.0';
    document.getElementById('ma_depth').value = '0.5';
    // Clear all reviewer notes
    for (const id of Object.values(NOTE_IDS)) {
        const el = document.getElementById(id);
        if (el) el.value = '';
    }
    // Reset weather days
    const weatherEl = document.getElementById('weatherDays');
    if (weatherEl) weatherEl.value = '0';
    // Reset scope checklist to defaults
    SCOPE_ITEMS.forEach(item => {
        const defRadio = document.getElementById(`scope_${item.id}_${item.default}`);
        if (defRadio) defRadio.checked = true;
        const noteEl = document.getElementById('scope_note_' + item.id);
        if (noteEl) noteEl.value = '';
    });
    calculateAll();
    showToast('Form reset');
}

// ===== EXPORT =====
function exportResults() {
    const proj = document.getElementById('projectName').value || 'Unnamed Project';
    const stdShift = gv('hoursPerDay');
    const maxS = gv('maxShift');
    const markup = gv('markupPercent') || gv('markupPercent2');

    let lines = [];
    lines.push('MAINTENANCE DIVISION ESTIMATE (v4.1)');
    lines.push('='.repeat(70));
    lines.push('Project: ' + proj);
    lines.push('Generated: ' + new Date().toLocaleString());
    lines.push('Standard Shift: ' + stdShift + 'h | Max Shift: ' + maxS + 'h');
    lines.push('');

    const hbBody = document.getElementById('hbBody');
    const rows = hbBody.querySelectorAll('tr');
    if (rows.length > 0 && !rows[0].textContent.includes('Enter quantities')) {
        lines.push('ESTIMATE SUMMARY (THREE-TIER)');
        lines.push('-'.repeat(70));
        lines.push(padR('Activity', 22) + padR('Crew', 6) + padR('Cons Hrs', 10) + padR('Std Hrs', 10) + padR('Agg Hrs', 10) + padR('Travel', 8));
        lines.push('-'.repeat(70));
        rows.forEach(row => {
            const cells = row.querySelectorAll('td');
            if (cells.length >= 9) {
                const name = cells[0].textContent.split('\n')[0].trim();
                lines.push(
                    padR(name, 22) +
                    padR(cells[1].textContent, 6) +
                    padR(cells[2].textContent + 'h', 10) +
                    padR(cells[4].textContent + 'h', 10) +
                    padR(cells[6].textContent + 'h', 10) +
                    padR(cells[8].textContent, 8)
                );
            }
        });
        lines.push('');
    }

    lines.push('='.repeat(70));
    lines.push('COST SUMMARY (Standard Tier)');
    lines.push('='.repeat(70));
    lines.push('Labor & Equipment: ' + document.getElementById('sum_laborTotal').textContent);
    lines.push('Materials: ' + document.getElementById('sum_matTotal').textContent);
    lines.push('Direct Cost: ' + document.getElementById('directCostTotal').textContent);
    lines.push('Markup (' + markup + '%): ' + document.getElementById('markupAmount').textContent);
    lines.push('BID PRICE: ' + document.getElementById('bidPrice').textContent);

    // === ESTIMATE CONFIDENCE ===
    const qSnap = window.lastCalcSnapshot;
    if (qSnap && qSnap.confidence) {
        const conf = qSnap.confidence;
        lines.push('');
        lines.push('Estimate Confidence: ' + (conf.composite * 100).toFixed(0) + '% ‚Äî ' + conf.descriptor);
    }

    // === SCOPE EXCLUSIONS & ASSUMPTIONS ===
    const qScope = collectAssumptions();
    if (qScope.included.length > 0 || qScope.excluded.length > 0) {
        lines.push('');
        lines.push('='.repeat(70));
        lines.push('SCOPE EXCLUSIONS & ASSUMPTIONS');
        lines.push('='.repeat(70));
        if (qScope.included.length > 0) {
            lines.push('INCLUDED:');
            qScope.included.forEach(s => { lines.push('  ‚úì ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
        if (qScope.excluded.length > 0) {
            lines.push('EXCLUDED:');
            qScope.excluded.forEach(s => { lines.push('  ‚úó ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
        if (qScope.na.length > 0) {
            lines.push('N/A:');
            qScope.na.forEach(s => { lines.push('  - ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
    }

    // === REVIEWER NOTES ===
    const qNotes = collectNotes();
    if (Object.keys(qNotes).length > 0) {
        lines.push('');
        lines.push('='.repeat(70));
        lines.push('REVIEWER NOTES');
        lines.push('='.repeat(70));
        for (const [key, text] of Object.entries(qNotes)) {
            lines.push('[' + (NOTE_LABELS[key] || key) + ']');
            lines.push(text);
            lines.push('');
        }
    }

    const text = lines.join('\n');
    navigator.clipboard.writeText(text).then(() => {
        showToast('Results copied to clipboard!');
    }).catch(() => {
        const ta = document.createElement('textarea');
        ta.value = text; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Results copied to clipboard!');
    });
}

function padR(str, len) {
    str = String(str);
    return str.length >= len ? str : str + ' '.repeat(len - str.length);
}

// ===== JOB ANALYSIS ENGINE =====
function generateAnalysis(snap) {
    if (!snap || !snap.unitChecks || snap.unitChecks.length === 0) return [];
    const observations = [];
    const acts = snap.activities;
    const activeCount = Object.values(acts).filter(a => a && a.enabled).length;
    const totalStdHrs = snap.hbRows.reduce((s, r) => s + r.tier.std.hours, 0);
    const totalTravel = snap.hbRows.reduce((s, r) => s + (r.travel || 0), 0);

    // RATE_CONFIDENCE moved to module scope

    // Field ops wheel stop production rates (Q21) vs calculator's single 80/day rate
    const WS_FIELD_RATES = { install: 80, reset: 155, removal: 220 };

    // Map unit check names back to snapshot keys and QTY_RANGES keys
    const checkMap = {
        'Crack Fill':           { actKey: 'crackFill',    qtyKey: 'cf',    getQty: () => acts.crackFill?.inputs?.lf },
        'Sealcoat':             { actKey: 'sealcoat',     qtyKey: 'sc',    getQty: () => acts.sealcoat?.inputs?.sf },
        '4" Lines':             { actKey: 'striping',     qtyKey: 'st4',   getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_4line')?.qty },
        '6" Lines':             { actKey: 'striping',     qtyKey: 'st6',   getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_6line')?.qty },
        '12" Lines':            { actKey: 'striping',     qtyKey: 'st12',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_12line')?.qty },
        '24" Lines':            { actKey: 'striping',     qtyKey: 'st24',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_24bar')?.qty },
        'Arrows':               { actKey: 'striping',     qtyKey: 'stAr',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_arrow')?.qty },
        'HC Symbols':           { actKey: 'striping',     qtyKey: 'stHC',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_hc')?.qty },
        'Stencils':             { actKey: 'striping',     qtyKey: 'stSt',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_stencil')?.qty },
        'Curb Paint':           { actKey: 'striping',     qtyKey: 'stCb',  getQty: () => snap.activities.striping?.lineItems?.find(i => i.id === 'st_curb')?.qty },
        'Asphalt Repair':       { actKey: 'asphaltRepair',qtyKey: 'ar',    getQty: () => acts.asphaltRepair?.inputs?.sf },
        'Mastic Crack Fill':    { actKey: 'mastic',       qtyKey: 'ma',    getQty: () => acts.mastic?.inputs?.lf },
        'Wheel Stops (new)':    { actKey: 'wheelStops',   qtyKey: 'ws',    getQty: () => acts.wheelStops?.inputs?.newQty },
        'Wheel Stops (reset)':  { actKey: 'wheelStops',   qtyKey: 'ws_r',  getQty: () => acts.wheelStops?.inputs?.resetQty },
        'Wheel Stops (remove)': { actKey: 'wheelStops',   qtyKey: 'ws_rm', getQty: () => acts.wheelStops?.inputs?.removeQty },
        'Signs (small)':        { actKey: 'signs',        qtyKey: 'sg_sm', getQty: () => acts.signs?.inputs?.postQty },
        'Signs (large)':        { actKey: 'signs',        qtyKey: 'sg_lg', getQty: () => acts.signs?.inputs?.bollQty },
        'Bollards':             { actKey: 'bollards',     qtyKey: 'bo',    getQty: () => acts.bollards?.inputs?.qty },
        'Speed Bumps':          { actKey: 'speedBumps',   qtyKey: 'sb',    getQty: () => acts.speedBumps?.inputs?.qty },
        'Speed Humps':          { actKey: 'speedHumps',   qtyKey: 'sh',    getQty: () => acts.speedHumps?.inputs?.qty },
        'Inlet Repair':         { actKey: 'inletRepair',  qtyKey: 'in_r',  getQty: () => acts.inletRepair?.inputs?.repairQty },
        'Inlet Reconstruct':    { actKey: 'inletRepair',  qtyKey: 'in_c',  getQty: () => acts.inletRepair?.inputs?.reconQty },
        'Paint Removal':        { actKey: 'paintRemoval', qtyKey: 'pr',    getQty: () => acts.paintRemoval?.inputs?.lf },
    };

    snap.unitChecks.forEach(check => {
        if (check.status === 'IN RANGE') return;
        const mapping = checkMap[check.name];
        if (!mapping) return;
        const act = acts[mapping.actKey];
        if (!act || !act.enabled) return;

        const reasons = [];
        const isHigh = check.status.includes('HIGH');
        const isLow = check.status.includes('LOW');
        const qtyRange = QTY_RANGES[mapping.qtyKey];
        const qty = check.qty;
        const stdHrs = act.tiers?.std?.hours || 0;
        const rateConf = RATE_CONFIDENCE[mapping.actKey];

        // --- Quantity-based reasoning (enhanced with Q1 crew-sizing context) ---
        if (qtyRange) {
            if (isHigh && qty <= qtyRange.low) {
                reasons.push(`Small quantity (${qty.toLocaleString()} ${check.unit}) ‚Äî fixed crew mobilization spread over fewer units inflates per-unit cost. Typical jobs have ${qtyRange.low.toLocaleString()}+ ${check.unit}.`);
                // Q1: When qty < 50% of daily max, a smaller crew could handle it
                if (act.rates?.prodPerDay && qty < act.rates.prodPerDay * 0.5) {
                    reasons.push(`Quantity is under 50% of the crew's daily capacity (${act.rates.prodPerDay.toLocaleString()}/day). Field experience (Q1) indicates a reduced crew size could handle this volume ‚Äî the bottleneck is the equipment, not hands. The extra person's value (staging, traffic) diminishes on small-scope simple jobs.`);
                }
            }
            if (isLow && qty > qtyRange.high * 0.75) {
                reasons.push(`Large quantity (${qty.toLocaleString()} ${check.unit}) ‚Äî crew mobilization amortized over many units reduces per-unit cost. Exceeds 75% of the typical high-end range.`);
            }
        }

        // --- Minimum shift utilization check ---
        if (stdHrs > 0 && act.rates?.prodPerDay && isHigh) {
            const prodRate = act.rates.prodPerDay;
            const rawProdHrs = (qty / prodRate) * snap.settings.stdShift;
            if (rawProdHrs < 3.5 && stdHrs >= 4) {
                const utilization = (rawProdHrs / stdHrs * 100).toFixed(0);
                reasons.push(`Low shift utilization: actual production work is ~${rawProdHrs.toFixed(1)} hrs but snapped to ${stdHrs.toFixed(0)}-hour minimum shift (${utilization}% utilization). The crew has capacity for more units in the same shift.`);
            }
        }

        // --- Setup/breakdown overhead (Q15, Q26: biggest missing element in rate-based estimating) ---
        if (isHigh && stdHrs > 0) {
            // Production rates measure productive output only ‚Äî every job starts/ends with non-productive time
            // Q15: Setup+breakdown is 10% of a large job, 25%+ of a small job
            const prodRate = act.rates?.prodPerDay;
            if (prodRate && qty > 0) {
                const rawProdHrs = (qty / prodRate) * snap.settings.stdShift;
                const overheadRatio = (stdHrs - rawProdHrs) / stdHrs;
                if (rawProdHrs <= 4 && overheadRatio > 0.20) {
                    reasons.push(`Setup/breakdown overhead: production rates measure productive output only. On small-scope jobs, the 1-2 hrs of non-productive time (equipment unloading, material heating, barricading, breakdown) represents ${(overheadRatio * 100).toFixed(0)}% of the shift. This is the most common reason field actuals exceed rate-based estimates.`);
                }
            }
        }

        // --- Phase-based reasoning (enhanced with Q13 phase efficiency) ---
        const phases = act.inputs?.phases;
        if (phases && phases > 1 && isHigh) {
            reasons.push(`Multiple phases (${phases}) = ${phases} separate mobilizations with setup/breakdown each time. Phase 2+ typically runs 10-15% faster (crew knows the site, staging is familiar), but the additional mobilization overhead still adds cost.`);
        }
        if (phases === 1 && isLow) {
            reasons.push('Single-phase job ‚Äî no repeated mobilization overhead, and all production is concentrated in one visit.');
        }

        // --- Travel-based reasoning (enhanced with Q8 distance thresholds) ---
        const travel = act.inputs?.travel || 0;
        if (travel > 0 && stdHrs > 0) {
            const travelRatio = travel / stdHrs;
            if (isHigh && travelRatio > 0.25) {
                reasons.push(`Travel time (${travel.toFixed(1)} hrs) is ${(travelRatio * 100).toFixed(0)}% of production hours (${stdHrs.toFixed(1)} hrs), significantly increasing per-unit cost.`);
                if (travel > 1.5) {
                    reasons.push(`Extended travel (>${(travel * 60).toFixed(0)} min round-trip). Jobs over 45-60 min one-way should consider staging equipment the night before on multi-day work, or scheduling nearby jobs on the same day to reduce dead-heading.`);
                }
            }
        }
        if (travel === 0 && isLow) {
            reasons.push('Zero travel time keeps costs purely production-driven.');
        }

        // --- Crack fill quantity reliability (Q18, Q25: most unreliable scope number) ---
        if (mapping.actKey === 'crackFill') {
            if (isLow) {
                reasons.push(`‚ö† Crack fill scope quantities are the least reliable number in maintenance estimating (Q18/Q25). Field quantities routinely come in 30-60% higher than scope descriptions. If this quantity came from a salesperson walkthrough rather than field measurement, actual production may require significantly more time and material.`);
            }
        }

        // --- Sealcoat crew sizing context (Q3: 3-man vs 4-man threshold) ---
        if (mapping.actKey === 'sealcoat') {
            const sf = act.inputs?.sf || 0;
            const crew = act.rates?.crewSize;
            if (isHigh && crew >= 4 && sf < 35000) {
                reasons.push(`Running a 4-person crew on ${sf.toLocaleString()} SF. The 4th crew member is required for manual spray bar operation, not volume. If equipment is upgraded to pneumatic spray bar, a 3-man crew is viable at equivalent production rates. Below ~35,000 SF per phase, the 4th person's support value (barricades, hose, staging) is less critical on smaller lots.`);
            }
            if (isLow && sf >= 52000) {
                reasons.push(`${sf.toLocaleString()} SF is in the efficient production zone for a ${crew}-person crew. Wide-open lots at this scale allow long, uninterrupted spray passes with minimal repositioning. 3-man baseline: 45K normal, 50K strong, 55K elite.`);
            }
        }

        // --- Asphalt-specific reasoning (enhanced with Q9 hot box vs triaxle context) ---
        if (mapping.actKey === 'asphaltRepair' && act.inputs?.depthConfig) {
            const dc = act.inputs.depthConfig;
            const layers = (dc.includes('2s') ? 1 : 0) + (dc.includes('4b') ? 1 : 0) + (dc.includes('d') ? 1 : 0);
            if (isHigh && layers >= 2) {
                const layerNames = [];
                if (dc.includes('2s')) layerNames.push('9.5mm surface');
                if (dc.includes('4b')) layerNames.push('19mm base');
                if (dc.includes('d')) layerNames.push('DGA');
                reasons.push(`Multi-layer depth config (${layerNames.join(' + ')}) increases material tonnage and cost per SF vs. surface-only jobs.`);
            }
            if (isLow && layers === 1) {
                reasons.push('Simple depth config (surface only) minimizes material layers and tonnage.');
            }
            // Q9: Hot box vs triaxle decision context
            if (act.crewType === 'large' && isHigh) {
                reasons.push(`Total asphalt exceeds 4 tons (${act.tonnage.totalAsphaltTons}T), triggering the triaxle crew at $${act.rates.crewRate.toFixed(2)}/hr (includes truck rental). The hot box carries ~3T and cannot handle this volume in one load. On sites with tight access, multiple hot box loads might be forced even above 4T (slower but feasible).`);
            }
            if (act.crewType === 'small' && act.tonnage?.totalAsphaltTons > 3 && act.tonnage?.totalAsphaltTons <= 4) {
                reasons.push(`Tonnage (${act.tonnage.totalAsphaltTons}T) is near the hot box limit (~3T capacity). If additional deterioration is found during saw cutting, tonnage may push past 4T requiring a triaxle crew at a higher rate.`);
            }
            // Patching rate confidence (Q17: widest variance of any work type)
            if (rateConf) {
                reasons.push(`Asphalt patching has the widest estimate-to-actuals variance of any work type (${rateConf.label}). Every patch differs in sub-base condition, depth, water presence, and whether the saw cut reveals worse deterioration than scoped. Build contingency accordingly.`);
            }
            // Material cost ratio check
            if (act.costs && act.costs.total > 0) {
                const matRatio = act.costs.material / act.costs.total;
                const laborRatio = 1 - matRatio;
                if (isLow && matRatio < 0.25) {
                    reasons.push(`Material cost (${fmt(act.costs.material)}) is only ${(matRatio * 100).toFixed(0)}% of total cost. Low asphalt unit pricing (${snap.settings.asphaltPrice > 0 ? '$' + snap.settings.asphaltPrice.toFixed(2) + '/ton' : 'not set'}) may be driving the low $/SF. Verify asphalt pricing is current.`);
                }
                if (isLow && laborRatio > 0.75 && act.tonnage?.totalAsphaltTons > 4) {
                    reasons.push(`Labor dominates at ${(laborRatio * 100).toFixed(0)}% of cost. The >4T triaxle crew rate ($${act.rates.crewRate.toFixed(2)}/hr) is being used, but high production capacity for ${act.inputs.sf.toLocaleString()} SF keeps labor-per-SF efficient.`);
                }
                if (isHigh && matRatio > 0.5 && layers >= 2) {
                    reasons.push(`Material is ${(matRatio * 100).toFixed(0)}% of total cost ‚Äî multi-layer depth configs concentrate more material cost per SF.`);
                }
            }
        }

        // --- Mastic-specific reasoning (enhanced with Q20 crack width production impact) ---
        if (mapping.actKey === 'mastic' && act.boxCalc) {
            if (isHigh && act.inputs.crackWidth * act.inputs.crackDepth > 1.0) {
                reasons.push(`Large crack cross-section (${act.inputs.crackWidth}" x ${act.inputs.crackDepth}") reduces coverage to ${act.boxCalc.lfPerBox.toFixed(1)} LF/box, increasing material cost per LF.`);
            }
            if (isLow && act.inputs.crackWidth * act.inputs.crackDepth <= 0.5) {
                reasons.push(`Small crack cross-section (${act.inputs.crackWidth}" x ${act.inputs.crackDepth}") yields ${act.boxCalc.lfPerBox.toFixed(1)} LF/box ‚Äî high material efficiency keeps per-LF cost low. Benchmark P25-P75 range reflects typical 1-2" cracks; narrower cracks naturally fall below that range.`);
            }
            // Q20: Wider cracks slow machine speed AND increase material consumption
            if (act.inputs?.crackWidth >= 2) {
                reasons.push(`Wide cracks (${act.inputs.crackWidth}"+) require slower machine speed for proper fill depth and consume 2-3x material per LF vs standard cracks. Production may drop to 750-800 LF/day vs the 1,000 LF/day standard rate. Also increases resupply frequency.`);
            }
            if (rateConf) {
                reasons.push(`Production rate confidence: ${rateConf.label} (${rateConf.reliability}).`);
            }
        }

        // --- Striping concurrency reasoning (Q4: confirmed concurrent ops model) ---
        if (mapping.actKey === 'striping' && act.concurrency) {
            const { machineHrs, handHrs, concurrentHrs } = act.concurrency;
            if (isLow && machineHrs > 0 && handHrs > 0) {
                const savedHrs = (machineHrs + handHrs) - concurrentHrs;
                if (savedHrs > 0.5) {
                    reasons.push(`High concurrency: machine (${machineHrs.toFixed(1)}h) and hand work (${handHrs.toFixed(1)}h) run in parallel. Hand crew starts opposite end from machine, working toward each other ‚Äî saves ${savedHrs.toFixed(1)} hrs vs sequential work. Duration = max(machine, hand), not sum.`);
                }
            }
            const machineLineNames = ['4" Lines', '6" Lines', '12" Lines', '24" Lines'];
            if (isHigh && machineLineNames.includes(check.name) && handHrs > machineHrs) {
                reasons.push(`Hand work (${handHrs.toFixed(1)}h) exceeds machine line work (${machineHrs.toFixed(1)}h), so the crew shift is driven by hand items. The ${check.name} share of crew cost includes time the machine crew is waiting on hand work.`);
            }
            // Q17: Striping machine rates are the most reliable (¬±10%)
            if (rateConf) {
                reasons.push(`Striping machine production rates are the most predictable of all work types (${rateConf.label}). Machine speed is very consistent. The main variable is hand work volume.`);
            }
        }

        // --- Wheel stop analysis (enhanced with Q21 differentiated field rates) ---
        if (mapping.actKey === 'wheelStops' && act.inputs) {
            const { newQty, resetQty, removeQty } = act.inputs;
            const totalWs = (newQty || 0) + (resetQty || 0) + (removeQty || 0);
            const opTypes = [(newQty || 0) > 0, (resetQty || 0) > 0, (removeQty || 0) > 0].filter(Boolean).length;
            if (opTypes > 1 && isHigh) {
                reasons.push(`Blended rate from ${opTypes} operation types (${newQty > 0 ? 'install' : ''}${resetQty > 0 ? ', reset' : ''}${removeQty > 0 ? ', remove' : ''}) affects the per-unit cost calculation.`.replace(', ,', ',').replace('(, ', '('));
            }
            // Q21: Compare user's differentiated rates against field benchmarks
            if (act.rates) {
                const { prodInstall, prodReset, prodRemoval } = act.rates;
                if ((newQty || 0) > 0 && prodInstall && Math.abs(prodInstall - WS_FIELD_RATES.install) / WS_FIELD_RATES.install > 0.15) {
                    reasons.push(`Install rate (${prodInstall}/day) differs >15% from field benchmark (${WS_FIELD_RATES.install}/day, Q21). ${prodInstall < WS_FIELD_RATES.install ? 'Lower rate adds conservatism.' : 'Higher rate assumes favorable conditions.'}`);
                }
                if ((resetQty || 0) > 0 && prodReset && Math.abs(prodReset - WS_FIELD_RATES.reset) / WS_FIELD_RATES.reset > 0.15) {
                    reasons.push(`Reset rate (${prodReset}/day) differs >15% from field benchmark (${WS_FIELD_RATES.reset}/day, Q21). Resets are ~2x faster than installs ‚Äî no drilling, just pull pins, reposition, reset.`);
                }
                if ((removeQty || 0) > 0 && prodRemoval && Math.abs(prodRemoval - WS_FIELD_RATES.removal) / WS_FIELD_RATES.removal > 0.15) {
                    reasons.push(`Removal rate (${prodRemoval}/day) differs >15% from field benchmark (${WS_FIELD_RATES.removal}/day, Q21). Removals are 2.5-3x faster than installs ‚Äî no alignment or anchoring needed.`);
                }
            }
        }

        // --- Inlet repair / reconstruction context (Q22: repair ‚Üí recon escalation) ---
        if (mapping.actKey === 'inletRepair') {
            if (check.name === 'Inlet Repair') {
                reasons.push(`‚ö† Inlet repair has the highest estimate-to-actuals variance (${rateConf?.label || '¬±40%'}). 20-30% of jobs scoped as "repair" end up as reconstruction once the structure is opened (Q22). Deterioration is largely invisible from the surface ‚Äî block wall condition, base washout, and pipe connections are unknown until excavation. Consider pricing 75% at repair rate / 25% at reconstruction rate as a hedge.`);
            }
            if (check.name === 'Inlet Reconstruct' && rateConf) {
                reasons.push(`Reconstruction scope inherently has high variance (${rateConf.label}). Unknown sub-surface conditions are the primary risk.`);
            }
        }

        // --- Bollard context (Q23: surface type and removal) ---
        if (mapping.actKey === 'bollards') {
            if (isHigh && act.inputs?.qty <= 4) {
                reasons.push(`Small bollard quantity (${act.inputs.qty}). A 3-person crew is typical for 4 or fewer bollards (Q23) ‚Äî reduced crew may be appropriate since the lower output per day doesn't matter when the job is small regardless.`);
            }
            if (rateConf && act.inputs?.qty > 0) {
                reasons.push(`Bollard production is ${rateConf.reliability} (Q23). Concrete surface installations run ~20-25% slower than asphalt. Remove-and-replace is ~1.5x slower than new install due to extraction and hole cleanup.`);
            }
        }

        // --- Signs with bollard mounts ---
        if (mapping.actKey === 'signs' && act.inputs?.bollQty > 0 && isHigh) {
            reasons.push(`Includes ${act.inputs.bollQty} bollard-mounted sign(s) at slower production rate (${act.rates.prodBoll}/day vs ${act.rates.prodPost}/day for post signs), plus bollard material cost.`);
        }

        // If no specific reasons found, add rate confidence context at minimum
        if (reasons.length === 0) {
            if (isHigh) reasons.push('Unit cost is above the P75 benchmark. Review quantities and production rates for this activity.');
            if (isLow) reasons.push('Unit cost is below the P25 benchmark. Verify production rates are achievable for this scope.');
            if (rateConf) {
                reasons.push(`Production rate confidence for this work type: ${rateConf.label} (${rateConf.reliability}).`);
            }
        }

        observations.push({
            activity: check.name,
            flag: check.status,
            qty: check.qty,
            unit: check.unit,
            unitCost: check.unitCost,
            benchmark: { p25: check.p25, med: check.med, p75: check.p75 },
            reasons
        });
    });

    // === Cross-activity observations ===
    const flaggedHigh = snap.unitChecks.filter(c => c.status.includes('HIGH')).length;
    const flaggedLow = snap.unitChecks.filter(c => c.status.includes('LOW')).length;
    const totalChecks = snap.unitChecks.length;

    // Standalone rate context ‚Äî benchmarks are from standalone-bid jobs
    if (activeCount > 1) {
        const reasons = [];
        reasons.push(`${activeCount} activities on this job. Benchmarks are based on standalone-bid production rates (Darrell's rates: one crew, one activity, full day). Multi-activity jobs naturally differ from standalone benchmarks.`);
        if (totalTravel > 0) {
            reasons.push(`Travel is calculated per-activity (${totalTravel.toFixed(1)} hrs total, ${activeCount} activities). On combined jobs, crews may share mobilization ‚Äî actual travel overhead per activity could be lower than calculated.`);
        }
        // Q14: Small add-on activities on multi-scope jobs
        const smallAddOns = [];
        Object.entries(acts).forEach(([key, a]) => {
            if (!a || !a.enabled || !a.rates?.prodPerDay) return;
            const qty = a.inputs?.lf || a.inputs?.sf || a.inputs?.qty || ((a.inputs?.newQty || 0) + (a.inputs?.resetQty || 0) + (a.inputs?.removeQty || 0)) || 0;
            if (qty > 0 && qty < a.rates.prodPerDay * 0.25) {
                const name = key.replace(/([A-Z])/g, ' $1').trim();
                smallAddOns.push(name);
            }
        });
        if (smallAddOns.length > 0) {
            reasons.push(`Potential tack-on activities: ${smallAddOns.join(', ')} ‚Äî each is under 25% of its crew's daily capacity (Q14). If these use similar crew/equipment as the primary scope, they may be absorbed into the primary crew's day rather than requiring separate mobilization. This would reduce actual hours vs calculated.`);
        }
        observations.push({ activity: 'Standalone Rate Context', flag: 'INFO', reasons });
    }

    // Q12: Sequencing context for multi-activity jobs
    if (activeCount > 1) {
        const hasPatching = acts.asphaltRepair?.enabled;
        const hasCrackFill = acts.crackFill?.enabled;
        const hasSealcoat = acts.sealcoat?.enabled;
        const hasStriping = acts.striping?.enabled;
        const sequence = [];
        if (hasPatching) sequence.push('Patch');
        if (hasCrackFill) sequence.push('Crack Fill');
        if (hasSealcoat) sequence.push('Sealcoat');
        if (hasStriping) sequence.push('Stripe');
        if (sequence.length >= 2) {
            const reasons = [`Standard field sequence: ${sequence.join(' ‚Üí ')} (Q12). Each layer depends on the one below being cured.`];
            if (hasCrackFill && hasSealcoat) reasons.push('Crack fill ‚Üí sealcoat requires 24-48 hrs cure time. Sealcoat ‚Üí striping requires 24-48 hrs cure. Scheduling in HeavyBid should account for cure windows between mobilizations.');
            observations.push({ activity: 'Work Sequencing', flag: 'INFO', reasons });
        }
    }

    if (totalStdHrs > 40) {
        observations.push({
            activity: 'Job Scale', flag: 'INFO', reasons: [
                `Large job scope: ${totalStdHrs.toFixed(1)} standard hours, ${snap.hbRows.reduce((s, r) => s + r.tier.std.days, 0)} crew-days across ${activeCount} activities. Verify shift scheduling in HeavyBid accounts for crew availability, sequencing, and cure windows between activities.`
            ]
        });
    }

    // Q5: Overtime threshold warning
    Object.entries(acts).forEach(([key, a]) => {
        if (!a || !a.enabled || !a.tiers?.std) return;
        if (a.tiers.std.hours > 10 && a.tiers.std.days === 1) {
            const name = key.replace(/([A-Z])/g, ' $1').trim();
            observations.push({
                activity: 'Overtime Alert', flag: 'INFO', reasons: [
                    `${name}: ${a.tiers.std.hours.toFixed(1)} hrs estimated on a single day exceeds the 10-hour practical limit (Q5). Consider splitting into multiple days or adding crew to finish within standard hours. A single crew past 10 hrs faces fatigue-related production loss.`
                ]
            });
        }
    });

    if (totalChecks > 2 && flaggedHigh > totalChecks * 0.5) {
        observations.push({
            activity: 'Pattern', flag: 'INFO', reasons: [
                `${flaggedHigh} of ${totalChecks} benchmarked activities are flagged HIGH. Common causes on multi-activity jobs: small quantities hitting minimum shift floors, per-activity travel overhead, or add-on work types that could be tacked onto a primary crew's day (Q14). Review whether combining activities in HeavyBid reduces effective overhead.`
            ]
        });
    }
    if (totalChecks > 2 && flaggedLow > totalChecks * 0.5) {
        observations.push({
            activity: 'Pattern', flag: 'INFO', reasons: [
                `${flaggedLow} of ${totalChecks} benchmarked activities are flagged LOW. Typical for high-volume jobs where production rates are fully utilized. Verify aggressive-tier hours are achievable ‚Äî field actuals for patching and inlet work can swing ${RATE_CONFIDENCE.asphaltRepair.label} and ${RATE_CONFIDENCE.inletRepair.label} respectively (Q17).`
            ]
        });
    }

    // === Clustering observations ===
    if (snap.clustering) {
        const clusters = Object.values(snap.clustering);
        const clusteredClusters = clusters.filter(c => c.clusteringApplied && c.hoursSaved > 0);

        if (clusteredClusters.length > 0) {
            clusteredClusters.forEach(cluster => {
                const actNames = cluster.activeActivities.map(a => {
                    const nameMap = { asphaltRepair:'Asphalt Repair', wheelStops:'Wheel Stops', bollards:'Bollards', signs:'Signs', inletRepair:'Inlet Repair', speedHumps:'Speed Humps', striping:'Striping', paintRemoval:'Paint Removal', speedBumps:'Speed Bumps' };
                    return nameMap[a.actKey] || a.actKey;
                });
                const reasons = [
                    `${cluster.name} shares mobilization across ${actNames.join(', ')}. Combined production: ${cluster.clusterTotalHrs.toFixed(1)}h vs ${cluster.standaloneTotal.toFixed(1)}h standalone (saves ${cluster.hoursSaved.toFixed(1)}h).`,
                    `Travel charged once at ${cluster.clusterTravel.toFixed(1)}h (max across activities) instead of ${cluster.activeActivities.reduce((s,a) => s + a.travel, 0).toFixed(1)}h cumulative.`
                ];
                // Tack-on detection within cluster
                cluster.activeActivities.forEach(act => {
                    if (act.proportion < 0.25 && cluster.activeActivities.length > 1) {
                        const name = actNames.find((_, i) => cluster.activeActivities[i].actKey === act.actKey) || act.actKey;
                        reasons.push(`${name} is a tack-on (${(act.proportion * 100).toFixed(0)}% of cluster production). Benefits from shared mobilization rather than requiring its own crew-day.`);
                    }
                });
                observations.push({ activity: `${cluster.icon} ${cluster.name} (Clustered)`, flag: 'INFO', reasons });
            });
        }
    }

    // Suggest clustering when off but would help
    if (!snap.clustering && activeCount > 1) {
        // Run a speculative cluster check
        const specCluster = clusterize(snap, snap.settings.stdShift, snap.settings.maxShift);
        // Restore the toggle check by temporarily forcing it - actually we can't override the DOM.
        // Instead, check if multiple activities share a cluster
        const clusterCounts = {};
        Object.entries(acts).forEach(([key, a]) => {
            if (!a || !a.enabled) return;
            const cId = ACTIVITY_CLUSTER[key];
            if (cId) clusterCounts[cId] = (clusterCounts[cId] || 0) + 1;
        });
        const multiActivityClusters = Object.entries(clusterCounts).filter(([_, count]) => count >= 2);
        if (multiActivityClusters.length > 0) {
            const clusterNames = multiActivityClusters.map(([cId]) => CREW_CLUSTERS[cId]?.name || cId);
            observations.push({
                activity: 'Crew Clustering Suggestion', flag: 'INFO', reasons: [
                    `Crew clustering is OFF, but ${multiActivityClusters.length} cluster(s) have multiple active activities: ${clusterNames.join(', ')}. Enabling clustering would reduce estimated hours by sharing mobilization across co-deployed activities.`
                ]
            });
        }
    }

    if (observations.length === 0 && totalChecks > 0) {
        observations.push({
            activity: 'All Activities', flag: 'OK', reasons: [
                'All calculated unit costs fall within the P25-P75 historical range from 347 jobs. Crew sizes and hours are consistent with Darrell\'s standalone production rates. Field confidence varies by work type ‚Äî striping is most reliable (¬±10%), patching has the widest variance (¬±35%).'
            ]
        });
    }

    return observations;
}

// ===== RENDER ANALYSIS =====
function renderAnalysis() {
    const section = document.getElementById('analysisSection');
    const body = document.getElementById('analysisBody');
    if (!section || !body) return;

    const snap = window.lastCalcSnapshot;
    if (!snap || !snap.unitChecks || snap.unitChecks.length === 0) {
        section.style.display = 'none';
        return;
    }

    const observations = generateAnalysis(snap);
    if (observations.length === 0) {
        section.style.display = 'none';
        return;
    }

    section.style.display = 'block';
    let html = '';

    observations.forEach(obs => {
        const flagLower = obs.flag.toLowerCase().replace(' ', '-');
        const badgeClass = flagLower.includes('high') ? (flagLower === 'very-high' ? 'very-high' : 'high') :
                           flagLower.includes('low') ? (flagLower === 'very-low' ? 'very-low' : 'low') :
                           flagLower === 'info' ? 'info' : 'ok';

        html += `<div class="analysis-card flag-${badgeClass}">`;
        html += `<div class="analysis-header">`;
        html += `<span class="activity-name">${obs.activity}</span>`;
        html += `<span class="analysis-badge ${badgeClass}">${obs.flag}</span>`;
        html += `</div>`;

        if (obs.unitCost !== undefined && obs.benchmark) {
            html += `<div class="analysis-benchmark">$${obs.unitCost.toFixed(2)}/${obs.unit} &nbsp;|&nbsp; Benchmark: $${obs.benchmark.p25.toFixed(2)} - $${obs.benchmark.med.toFixed(2)} - $${obs.benchmark.p75.toFixed(2)}</div>`;
        }

        html += `<ul class="analysis-reasons">`;
        obs.reasons.forEach(r => { html += `<li>${r}</li>`; });
        html += `</ul></div>`;
    });

    body.innerHTML = html;
}

// ===== COMPREHENSIVE EXPORT (Text) =====
function exportComprehensiveText() {
    const snap = window.lastCalcSnapshot;
    if (!snap) { showToast('Calculate first'); return; }
    const L = [];
    const W = 80;

    L.push('MAINTENANCE DIVISION ESTIMATING CALCULATOR - FULL REPORT (v' + snap.meta.version + ')');
    L.push('='.repeat(W));
    L.push('Project: ' + snap.meta.projectName);
    L.push('Generated: ' + new Date().toLocaleString());
    L.push('');

    // ‚îÄ‚îÄ PRIMARY OUTPUT: CREW & DURATION SUMMARY (HeavyBid Input Data) ‚îÄ‚îÄ
    if (snap.hbRows.length > 0) {
        L.push('='.repeat(W));
        L.push('CREW & DURATION SUMMARY');
        L.push('Primary output for HeavyBid line-item entry');
        L.push('='.repeat(W));
        L.push(padR('Activity', 22) + padR('Crew', 6) + padR('Cons', 9) + padR('Std', 9) + padR('Agg', 9) + padR('Travel', 8));
        L.push('-'.repeat(W));
        let totC = 0, totS = 0, totA = 0, totT = 0;
        snap.hbRows.forEach(r => {
            const c = r.tier.cons.hours, s = r.tier.std.hours, a = r.tier.agg.hours, tv = r.travel || 0;
            totC += c; totS += s; totA += a; totT += tv;
            L.push(padR(r.name, 22) + padR(r.tier.std.crew, 6) + padR(c.toFixed(1) + 'h', 9) + padR(s.toFixed(1) + 'h', 9) + padR(a.toFixed(1) + 'h', 9) + padR(tv > 0 ? tv.toFixed(1) + 'h' : '-', 8));
        });
        L.push('-'.repeat(W));
        L.push(padR('TOTAL', 22) + padR('-', 6) + padR(totC.toFixed(1) + 'h', 9) + padR(totS.toFixed(1) + 'h', 9) + padR(totA.toFixed(1) + 'h', 9) + padR(totT > 0 ? totT.toFixed(1) + 'h' : '-', 8));
        L.push('');
        L.push('Shift Settings: Standard ' + snap.settings.stdShift + 'h | Max ' + snap.settings.maxShift + 'h');
        L.push('Three-Tier: Conservative (80% prod) | Standard (100%) | Aggressive (120%)');
        L.push('');
    }

    // ‚îÄ‚îÄ CREW DEPLOYMENT (Clustered) ‚îÄ‚îÄ
    if (snap.clustering) {
        const clusters = Object.values(snap.clustering).filter(c => c.activeActivities && c.activeActivities.length > 0);
        if (clusters.length > 0) {
            const actDisplayNames = {
                asphaltRepair: 'Asphalt Repair', wheelStops: 'Wheel Stops', bollards: 'Bollards',
                signs: 'Signs', inletRepair: 'Inlet Repair', speedHumps: 'Speed Humps',
                striping: 'Striping', paintRemoval: 'Paint Removal', speedBumps: 'Speed Bumps',
                sealcoat: 'Sealcoating', crackFill: 'Crack Filling', mastic: 'Mastic'
            };

            L.push('='.repeat(W));
            L.push('CREW DEPLOYMENT (Clustered)');
            L.push('Shared mobilization - hours sum to real crew-days');
            L.push('='.repeat(W));

            let totalClusteredHrs = 0, totalStandaloneHrs = 0, physicalCrews = 0;

            clusters.forEach(cluster => {
                physicalCrews++;
                L.push('');
                const maxCrew = Math.max(...cluster.activeActivities.map(a => a.crewSize));
                L.push(`${cluster.name} - ${maxCrew}-man crew`);
                L.push('-'.repeat(50));

                cluster.activeActivities.forEach(act => {
                    const name = actDisplayNames[act.actKey] || act.actKey;
                    L.push(`  ${padR(name, 20)} ${padR(act.apportionedHrs.toFixed(1) + 'h', 8)} (${(act.proportion * 100).toFixed(0)}%)`);
                });

                if (cluster.clusteringApplied) {
                    L.push(`  Cluster shift: ${cluster.clusterTotalHrs.toFixed(1)}h | Travel: ${cluster.clusterTravel.toFixed(1)}h | Saved: ${cluster.hoursSaved.toFixed(1)}h vs standalone`);
                    totalClusteredHrs += cluster.clusterTotalHrs;
                    totalStandaloneHrs += cluster.standaloneTotal;
                } else {
                    const act = cluster.activeActivities[0];
                    totalClusteredHrs += act.apportionedHrs;
                    totalStandaloneHrs += act.apportionedHrs;
                }
            });

            L.push('');
            L.push(`Job: ${physicalCrews} crews, ${totalClusteredHrs.toFixed(1)}h clustered (${totalStandaloneHrs.toFixed(1)}h standalone)`);
            L.push('');
        }
    }

    // ‚îÄ‚îÄ ESTIMATE CONFIDENCE ‚îÄ‚îÄ
    if (snap.confidence) {
        const conf = snap.confidence;
        const ex = conf.explain;
        L.push('='.repeat(W));
        L.push('ESTIMATE CONFIDENCE (AACE RP 42R-08)');
        L.push('='.repeat(W));
        L.push('');
        L.push('  Production Reliability (35%): ' + (conf.prodReliability * 100).toFixed(0) + '%');
        L.push('  How predictable are the production rates? Cost-weighted field variance bands.');
        if (ex && ex.prodDrivers) {
            ex.prodDrivers.forEach(d => {
                const costPct = ex.totalDirectCost > 0 ? ((d.cost / ex.totalDirectCost) * 100).toFixed(0) : 0;
                L.push('    [' + d.band + '] ' + d.name + ' (' + costPct + '% of cost) ‚Äî ' + d.reliability);
            });
        }
        L.push('');
        L.push('  Benchmark Alignment (30%):    ' + (conf.benchAlignment * 100).toFixed(0) + '%');
        L.push('  ' + conf.details.inRange + ' of ' + conf.details.totalChecks + ' line items within P25-P75 historical range.');
        if (ex && ex.benchOutliers && ex.benchOutliers.length > 0) {
            ex.benchOutliers.forEach(o => {
                L.push('    [' + o.status + '] ' + o.name + ': $' + o.unitCost.toFixed(2) + '/' + o.unit + ' (range $' + o.p25.toFixed(2) + '-$' + o.p75.toFixed(2) + ')');
            });
        }
        L.push('');
        L.push('  Scope Definition (20%):       ' + (conf.scopeDefinition * 100).toFixed(0) + '%');
        L.push('  ' + conf.details.scopeInRange + ' of ' + conf.details.scopeChecked + ' line items within typical quantity bands.');
        if (ex && ex.scopeDrivers && ex.scopeDrivers.length > 0) {
            ex.scopeDrivers.forEach(s => {
                L.push('    [' + s.dir.toUpperCase() + '] ' + s.name + ': ' + s.qty.toLocaleString() + ' ' + s.unit + ' (typical ' + s.low.toLocaleString() + '-' + s.high.toLocaleString() + ')');
            });
        }
        L.push('');
        L.push('  Data Quality (15%):           ' + (conf.dataQuality * 100).toFixed(0) + '%');
        L.push('  Benchmark robustness by sample size, weighted by cost share.');
        if (ex && ex.dqDrivers) {
            const dqTotal = ex.dqDrivers.reduce((s, d) => s + d.cost, 0);
            ex.dqDrivers.forEach(d => {
                const costPct = dqTotal > 0 ? ((d.cost / dqTotal) * 100).toFixed(0) : 0;
                L.push('    [n=' + d.n + '] ' + d.name + ' ‚Äî ' + d.tier + ' (' + costPct + '% of cost)');
            });
        }
        L.push('');
        L.push('  COMPOSITE:                    ' + (conf.composite * 100).toFixed(0) + '% ‚Äî ' + conf.descriptor);
        L.push('');
    }

    // ‚îÄ‚îÄ CALENDAR DURATION ‚îÄ‚îÄ
    if (snap.calendar && snap.calendar.timeline.length > 0) {
        L.push('='.repeat(W));
        L.push('CALENDAR DURATION ESTIMATE');
        L.push('='.repeat(W));
        snap.calendar.timeline.forEach(entry => {
            const dayLabel = entry.days === 1 ? `Day ${entry.startDay}` : `Day ${entry.startDay}-${entry.endDay}`;
            if (entry.type === 'cure') {
                L.push(padR(dayLabel, 14) + '‚è≥ ' + entry.name);
            } else if (entry.type === 'weather') {
                L.push(padR(dayLabel, 14) + 'üåßÔ∏è ' + entry.name);
            } else {
                L.push(padR(dayLabel, 14) + padR(entry.name, 40) + padR(entry.crew + '-man', 8) + entry.hours.toFixed(1) + 'h');
            }
        });
        L.push('-'.repeat(W));
        L.push(`Total: ${snap.calendar.totalDays} calendar days (${snap.calendar.workDays} work + ${snap.calendar.cureDays} cure + ${snap.calendar.weatherDays} weather)`);
        L.push('');
    }

    // ‚îÄ‚îÄ ACTIVITY DETAIL BLOCKS ‚îÄ‚îÄ
    L.push('='.repeat(W));
    L.push('ACTIVITY DETAILS');
    L.push('Crew sizing, production rates, and duration calculations');
    L.push('='.repeat(W));
    L.push('');

    const actNames = {
        crackFill: 'CRACK FILLING', sealcoat: 'SEALCOATING', striping: 'STRIPING',
        asphaltRepair: 'ASPHALT REPAIRS', mastic: 'MASTIC CRACK FILL', wheelStops: 'WHEEL STOPS',
        signs: 'SIGNS', bollards: 'BOLLARDS', speedBumps: 'RUBBER SPEED BUMPS',
        speedHumps: 'SPEED HUMPS', inletRepair: 'INLET REPAIR', paintRemoval: 'PAINT REMOVAL'
    };

    Object.entries(snap.activities).forEach(([key, act]) => {
        if (!act || !act.enabled) return;
        const name = actNames[key] || key;
        L.push('-'.repeat(W));
        L.push(name);
        L.push('-'.repeat(W));

        // Crew & production rate (lead with HeavyBid-relevant data)
        if (act.rates) {
            const rateParts = [];
            if (act.rates.crewSize) rateParts.push('Crew: ' + act.rates.crewSize);
            if (act.rates.crewRate) rateParts.push('Crew Rate: $' + act.rates.crewRate.toFixed(2) + '/hr');
            if (act.rates.prodPerDay) rateParts.push('Production: ' + act.rates.prodPerDay.toLocaleString() + '/day');
            L.push('  ' + rateParts.join(' | '));
        }

        // Three-tier hours/days (the primary deliverable)
        if (act.tiers) {
            L.push('  Duration (three-tier):');
            L.push('    Conservative: ' + act.tiers.cons.hours.toFixed(1) + 'h / ' + act.tiers.cons.days + ' days');
            L.push('    Standard:     ' + act.tiers.std.hours.toFixed(1) + 'h / ' + act.tiers.std.days + ' days' + (act.tiers.std.hustle ? ' (hustle)' : ''));
            L.push('    Aggressive:   ' + act.tiers.agg.hours.toFixed(1) + 'h / ' + act.tiers.agg.days + ' days');
        }

        // Scope inputs
        const inp = act.inputs || {};
        const inputParts = [];
        if (inp.lf !== undefined) inputParts.push('Qty: ' + inp.lf.toLocaleString() + ' LF');
        if (inp.sf !== undefined) inputParts.push('Qty: ' + inp.sf.toLocaleString() + ' SF');
        if (inp.qty !== undefined) inputParts.push('Qty: ' + inp.qty.toLocaleString());
        if (inp.newQty !== undefined) inputParts.push('New: ' + inp.newQty + ', Reset: ' + inp.resetQty + ', Remove: ' + inp.removeQty);
        if (inp.postQty !== undefined) inputParts.push('Post: ' + inp.postQty + ', Bollard: ' + inp.bollQty);
        if (inp.repairQty !== undefined) inputParts.push('Repair: ' + inp.repairQty + ', Reconstruct: ' + inp.reconQty + ', Castings: ' + inp.castingQty);
        if (inp.phases) inputParts.push('Phases: ' + inp.phases);
        if (inp.travel) inputParts.push('Travel: ' + inp.travel + 'h');
        if (inp.depthConfig) inputParts.push('Depth: ' + inp.depthConfig);
        if (inp.crackWidth) inputParts.push('Crack: ' + inp.crackWidth + '" x ' + inp.crackDepth + '"');
        if (inputParts.length > 0) L.push('  Scope: ' + inputParts.join(' | '));

        // Tonnage (asphalt/speed humps)
        if (act.tonnage) {
            const t = act.tonnage;
            if (t.surfTons !== undefined) {
                L.push('  Tonnage: Surface ' + t.surfTons + 'T, Base ' + t.baseTons + 'T, DGA ' + t.dgaTons + 'T (Total Asphalt: ' + t.totalAsphaltTons + 'T)');
            } else {
                L.push('  Tonnage: ' + t.totalTons + 'T (' + t.tonsPerHump + 'T/hump)');
            }
        }

        // Mastic box calc
        if (act.boxCalc) {
            L.push('  Box Calc: ' + act.boxCalc.lfPerBox.toFixed(1) + ' LF/box, ' + act.boxCalc.boxesNeeded + ' boxes needed');
        }

        // Striping line items
        if (act.lineItems && act.lineItems.length > 0) {
            L.push('  Line Items:');
            act.lineItems.forEach(li => {
                L.push('    ' + padR(li.id.replace('st_', ''), 12) + padR(li.qty.toLocaleString(), 10) + padR(li.hours.toFixed(1) + 'h', 8) + fmt(li.matCost) + ' mat  [' + li.group + ']');
            });
            L.push('  Concurrency: Machine ' + act.concurrency.machineHrs.toFixed(1) + 'h | Hand ' + act.concurrency.handHrs.toFixed(1) + 'h | Effective ' + act.concurrency.concurrentHrs.toFixed(1) + 'h');
        }

        // Cost detail (secondary ‚Äî HeavyBid owns final costing)
        if (act.costs) {
            L.push('  Cost Detail (calculator estimate):');
            if (act.costs.laborShift !== undefined) L.push('    Labor (shift):  ' + fmt(act.costs.laborShift));
            if (act.costs.laborTotal !== undefined) L.push('    Labor (total):  ' + fmt(act.costs.laborTotal));
            if (act.costs.laborTravel > 0) L.push('    Labor (travel): ' + fmt(act.costs.laborTravel));
            if (act.costs.material !== undefined) L.push('    Material:       ' + fmt(act.costs.material));
            if (act.costs.machineRental) L.push('    Machine Rental: ' + fmt(act.costs.machineRental));
            if (act.costs.rental) L.push('    Grinder Rental: ' + fmt(act.costs.rental));
            L.push('    TOTAL:          ' + fmt(act.costs.total));
        }
        L.push('');
    });

    // ‚îÄ‚îÄ UNIT COST CHECKS ‚îÄ‚îÄ
    if (snap.unitChecks.length > 0) {
        L.push('='.repeat(W));
        L.push('UNIT COST REASONABLENESS CHECK');
        const hasAnyClustered = snap.unitChecks.some(c => c.clustered);
        L.push(hasAnyClustered
            ? 'Benchmarked against 347 historical jobs | Cluster-adjusted unit costs shown where applicable'
            : 'Benchmarked against 347 historical jobs (Darrell\'s standalone rates)');
        L.push('='.repeat(W));
        snap.unitChecks.forEach(c => {
            let line = padR(c.name + (c.clustered ? ' *' : ''), 24) + padR(c.qty.toLocaleString() + ' ' + c.unit, 12) + padR('$' + c.unitCost.toFixed(2) + '/' + c.unit, 14) + padR('P25-P75: $' + c.p25.toFixed(2) + '-$' + c.p75.toFixed(2), 24) + c.status;
            if (c.clustered && c.standaloneUnitCost !== undefined) {
                line += '  (standalone: $' + c.standaloneUnitCost.toFixed(2) + '/' + c.unit + ')';
            }
            L.push(line);
        });
        if (hasAnyClustered) L.push('* = unit cost reflects shared crew mobilization (clustered)');
        L.push('');
    }

    // ‚îÄ‚îÄ ANALYSIS OBSERVATIONS ‚îÄ‚îÄ
    const analysis = generateAnalysis(snap);
    if (analysis.length > 0) {
        L.push('='.repeat(W));
        L.push('JOB ANALYSIS');
        L.push('='.repeat(W));
        analysis.forEach(obs => {
            const header = obs.unitCost !== undefined ? `[${obs.flag}] ${obs.activity} - $${obs.unitCost.toFixed(2)}/${obs.unit}` : `[${obs.flag}] ${obs.activity}`;
            L.push(header);
            obs.reasons.forEach(r => { L.push('  - ' + r); });
            L.push('');
        });
    }

    // ‚îÄ‚îÄ COST SUMMARY (sanity check ‚Äî HeavyBid owns final bid pricing) ‚îÄ‚îÄ
    L.push('='.repeat(W));
    L.push('COST SUMMARY ‚Äî CALCULATOR ESTIMATE (Standard Tier)');
    L.push('Reference only ‚Äî HeavyBid owns final cost buildup, overhead, and bid pricing');
    L.push('='.repeat(W));
    L.push('Labor & Equipment:  ' + fmt(snap.summary.totalLabor));
    L.push('Materials:          ' + fmt(snap.summary.totalMat));
    L.push('Direct Cost:        ' + fmt(snap.summary.directCost));
    L.push('Markup (' + snap.summary.markupPercent + '%):       ' + fmt(snap.summary.markupAmount));
    L.push('Calculator Total:   ' + fmt(snap.summary.bidPrice));
    L.push('');
    L.push('Material Pricing: Asphalt 9.5mm $' + snap.settings.asphaltPrice + '/ton | 19mm Base $' + snap.settings.baseAsphaltPrice + '/ton | DGA $' + snap.settings.dgaPrice + '/ton');

    // === SCOPE EXCLUSIONS & ASSUMPTIONS ===
    const fScope = snap.scopeAssumptions || collectAssumptions();
    if (fScope.included.length > 0 || fScope.excluded.length > 0) {
        L.push('');
        L.push('='.repeat(W));
        L.push('SCOPE EXCLUSIONS & ASSUMPTIONS');
        L.push('Per ASPE Standard Estimating Practice ‚Äî document all basis and exclusions');
        L.push('='.repeat(W));
        if (fScope.included.length > 0) {
            L.push('INCLUDED:');
            fScope.included.forEach(s => { L.push('  ‚úì ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
        if (fScope.excluded.length > 0) {
            L.push('EXCLUDED:');
            fScope.excluded.forEach(s => { L.push('  ‚úó ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
        if (fScope.na.length > 0) {
            L.push('N/A:');
            fScope.na.forEach(s => { L.push('  - ' + s.name + (s.note ? ' ‚Äî ' + s.note : '')); });
        }
        L.push('');
    }

    // === REVIEWER NOTES ===
    const fNotes = collectNotes();
    if (Object.keys(fNotes).length > 0) {
        L.push('');
        L.push('='.repeat(W));
        L.push('REVIEWER NOTES');
        L.push('='.repeat(W));
        for (const [key, noteText] of Object.entries(fNotes)) {
            L.push('[' + (NOTE_LABELS[key] || key) + ']');
            L.push(noteText);
            L.push('');
        }
    }

    const text = L.join('\n');
    navigator.clipboard.writeText(text).then(() => {
        showToast('Full report copied to clipboard!');
    }).catch(() => {
        const ta = document.createElement('textarea');
        ta.value = text; document.body.appendChild(ta);
        ta.select(); document.execCommand('copy');
        document.body.removeChild(ta);
        showToast('Full report copied to clipboard!');
    });
}

// ===== JSON EXPORT =====
function exportJSON() {
    const snap = window.lastCalcSnapshot;
    if (!snap) { showToast('Calculate first'); return; }
    snap.analysis = generateAnalysis(snap);
    const json = JSON.stringify(snap, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = (snap.meta.projectName.replace(/[^a-zA-Z0-9]/g, '_') || 'estimate') + '_' + new Date().toISOString().slice(0, 10) + '.json';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
    showToast('JSON exported!');
}

// ===== PRINT / PDF =====
function printEstimate() {
    const snap = window.lastCalcSnapshot;
    if (!snap) { showToast('Calculate first'); return; }

    const analysis = generateAnalysis(snap);
    const proj = snap.meta.projectName || 'Unnamed Project';
    const W = 80;

    // Build clean HTML document
    let h = `<!DOCTYPE html><html><head><meta charset="utf-8"><title>${proj} ‚Äî Estimate</title>
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Sans:wght@400;500;600;700&family=JetBrains+Mono:wght@400;600;700&display=swap" rel="stylesheet">
<style>
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:'IBM Plex Sans',sans-serif;font-size:11px;color:#1a1a1a;line-height:1.5;padding:20px 30px;max-width:900px;margin:0 auto}
h1{font-size:16px;margin-bottom:2px}
h2{font-size:13px;margin:18px 0 6px;padding-bottom:3px;border-bottom:2px solid #1a1a1a}
h3{font-size:11px;margin:12px 0 4px;color:#555}
table{width:100%;border-collapse:collapse;margin:6px 0 12px;font-size:10px}
th,td{padding:3px 6px;text-align:left;border-bottom:1px solid #ddd}
th{background:#f5f5f5;font-weight:700;font-size:9px;text-transform:uppercase;letter-spacing:0.3px}
.mono{font-family:'JetBrains Mono',monospace}
.right{text-align:right}
.center{text-align:center}
.muted{color:#777}
.badge{display:inline-block;padding:1px 5px;border-radius:3px;font-size:8px;font-weight:700;letter-spacing:0.3px}
.badge.in-range{background:#e6f9ee;color:#0a8f3e}
.badge.high,.badge.low{background:#fff3e0;color:#e65100}
.badge.very-high,.badge.very-low{background:#ffeaea;color:#c62828}
.section{margin-bottom:14px}
.cost-grid{display:grid;grid-template-columns:1fr 1fr 1fr;gap:12px;margin:6px 0}
.cost-grid>div{border:1px solid #ddd;border-radius:4px;padding:8px}
.cost-line{display:flex;justify-content:space-between;padding:1px 0;font-size:10px}
.cost-line.subtotal{border-top:1px solid #999;font-weight:700;margin-top:4px;padding-top:4px}
.totals{background:#f5f5f5;border:1px solid #ccc;border-radius:4px;padding:10px;margin:8px 0}
.totals .row{display:flex;justify-content:space-between;padding:2px 0;font-size:11px}
.totals .grand{font-size:14px;font-weight:800;border-top:2px solid #1a1a1a;margin-top:4px;padding-top:6px}
.conf-bar{display:flex;align-items:center;gap:6px;margin:3px 0;font-size:10px}
.conf-bar .track{flex:1;height:10px;background:#eee;border-radius:5px;overflow:hidden}
.conf-bar .fill{height:100%;border-radius:5px}
.timeline-row{display:grid;grid-template-columns:70px 1fr 60px 60px;gap:4px;padding:3px 4px;font-size:10px;border-bottom:1px solid #eee}
.timeline-row.cure{background:#fff8e1;font-style:italic;color:#888}
.scope-section{margin:4px 0}
.scope-section .item{display:flex;gap:6px;font-size:10px;padding:1px 0}
.scope-section .tag{font-weight:700;width:40px}
.scope-section .tag.incl{color:#0a8f3e}
.scope-section .tag.excl{color:#e65100}
.scope-section .tag.na{color:#888}
.footer{margin-top:20px;padding-top:8px;border-top:1px solid #ccc;font-size:9px;color:#888;text-align:center}
.obs{margin-bottom:8px;padding:4px 6px;border-left:3px solid #ddd;font-size:10px}
.obs.high{border-color:#e65100}
.obs.low{border-color:#0a8f3e}
.notes-block{background:#f9f9f9;border:1px solid #ddd;border-radius:4px;padding:6px 8px;font-size:10px;margin:4px 0}
@media print{body{padding:10px 15px}h2{page-break-after:avoid}table{page-break-inside:avoid}}
</style></head><body>`;

    // Header
    h += `<h1>${proj}</h1>`;
    h += `<div class="muted" style="margin-bottom:12px;">Generated: ${new Date().toLocaleString()} | Maintenance Division Estimating Calculator v${snap.meta.version}</div>`;

    // Crew & Duration Summary
    if (snap.hbRows.length > 0) {
        h += '<h2>Crew & Duration Summary</h2>';
        h += '<table><thead><tr><th>Activity</th><th class="center">Crew</th><th class="right">Cons Hrs</th><th class="right">Cons Days</th><th class="right">Std Hrs</th><th class="right">Std Days</th><th class="right">Agg Hrs</th><th class="right">Agg Days</th><th class="right">Travel</th></tr></thead><tbody>';
        snap.hbRows.forEach(r => {
            h += `<tr><td>${r.name}</td><td class="center">${r.tier.std.crew}</td><td class="right mono">${r.tier.cons.hours.toFixed(1)}</td><td class="right">${r.tier.cons.days}</td><td class="right mono">${r.tier.std.hours.toFixed(1)}</td><td class="right">${r.tier.std.days}</td><td class="right mono">${r.tier.agg.hours.toFixed(1)}</td><td class="right">${r.tier.agg.days}</td><td class="right mono">${r.travel ? r.travel.toFixed(1) + 'h' : '-'}</td></tr>`;
        });
        h += '</tbody></table>';
    }

    // Calendar Duration
    if (snap.calendar && snap.calendar.timeline.length > 0) {
        h += '<h2>Calendar Duration</h2>';
        snap.calendar.timeline.forEach(entry => {
            const dayLabel = entry.days === 1 ? 'Day ' + entry.startDay : 'Day ' + entry.startDay + '-' + entry.endDay;
            if (entry.type === 'work') {
                h += '<div class="timeline-row"><span class="mono">' + dayLabel + '</span><span>' + entry.name + '</span><span class="center">' + entry.crew + '-man</span><span class="right mono">' + entry.hours.toFixed(1) + 'h</span></div>';
            } else {
                h += '<div class="timeline-row cure"><span class="mono">' + dayLabel + '</span><span>' + (entry.type === 'cure' ? '‚è≥ ' : 'üåßÔ∏è ') + entry.name + '</span><span>-</span><span>-</span></div>';
            }
        });
        h += '<div style="font-weight:700;margin-top:6px;font-size:11px;">Total: ' + snap.calendar.totalDays + ' calendar days (' + snap.calendar.workDays + ' work + ' + snap.calendar.cureDays + ' cure + ' + snap.calendar.weatherDays + ' weather)</div>';
    }

    // Confidence
    if (snap.confidence) {
        const conf = snap.confidence;
        const ex = conf.explain;
        h += '<h2>Estimate Confidence</h2>';
        function confBar(label, val) {
            const pct = (val * 100).toFixed(0);
            const col = val >= 0.80 ? '#0a8f3e' : val >= 0.65 ? '#0288d1' : val >= 0.50 ? '#f57c00' : '#c62828';
            return '<div class="conf-bar"><span style="width:160px;">' + label + '</span><div class="track"><div class="fill" style="width:' + pct + '%;background:' + col + ';"></div></div><span class="mono" style="width:40px;text-align:right;">' + pct + '%</span></div>';
        }
        function drvColor(score) { return score >= 0.85 ? '#0a8f3e' : score >= 0.70 ? '#0288d1' : score >= 0.50 ? '#f57c00' : '#c62828'; }
        function drvTag(text, col) { return '<span class="mono" style="font-size:9px;font-weight:700;color:' + col + ';">' + text + '</span>'; }

        // Production Reliability
        h += confBar('Production Reliability (35%)', conf.prodReliability);
        h += '<div style="font-size:9px;color:#777;margin:2px 0 6px 0;line-height:1.5;">';
        h += '<em>How predictable are the production rates? Cost-weighted average of field variance bands.</em>';
        if (ex && ex.prodDrivers) {
            ex.prodDrivers.forEach(function(d) {
                var costPct = ex.totalDirectCost > 0 ? ((d.cost / ex.totalDirectCost) * 100).toFixed(0) : 0;
                h += '<br>' + drvTag(d.band, drvColor(d.bandScore)) + ' ' + d.name + ' (' + costPct + '% of cost) ‚Äî ' + d.reliability;
            });
        }
        h += '</div>';

        // Benchmark Alignment
        h += confBar('Benchmark Alignment (30%)', conf.benchAlignment);
        h += '<div style="font-size:9px;color:#777;margin:2px 0 6px 0;line-height:1.5;">';
        h += '<em>' + conf.details.inRange + ' of ' + conf.details.totalChecks + ' line items within P25-P75 historical range.</em>';
        if (ex && ex.benchOutliers && ex.benchOutliers.length > 0) {
            ex.benchOutliers.forEach(function(o) {
                var col = o.status.includes('VERY') ? '#c62828' : '#f57c00';
                h += '<br>' + drvTag(o.status, col) + ' ' + o.name + ': $' + o.unitCost.toFixed(2) + '/' + o.unit + ' (range $' + o.p25.toFixed(2) + '-$' + o.p75.toFixed(2) + ')';
            });
        }
        h += '</div>';

        // Scope Definition
        h += confBar('Scope Definition (20%)', conf.scopeDefinition);
        h += '<div style="font-size:9px;color:#777;margin:2px 0 6px 0;line-height:1.5;">';
        h += '<em>' + conf.details.scopeInRange + ' of ' + conf.details.scopeChecked + ' line items within typical quantity bands.</em>';
        if (ex && ex.scopeDrivers && ex.scopeDrivers.length > 0) {
            ex.scopeDrivers.forEach(function(s) {
                h += '<br>' + drvTag(s.dir.toUpperCase(), '#f57c00') + ' ' + s.name + ': ' + s.qty.toLocaleString() + ' ' + s.unit + ' (typical ' + s.low.toLocaleString() + '-' + s.high.toLocaleString() + ')';
            });
        }
        h += '</div>';

        // Data Quality
        h += confBar('Data Quality (15%)', conf.dataQuality);
        h += '<div style="font-size:9px;color:#777;margin:2px 0 6px 0;line-height:1.5;">';
        h += '<em>Benchmark robustness by sample size, weighted by cost share.</em>';
        if (ex && ex.dqDrivers) {
            var dqTotal = ex.dqDrivers.reduce(function(s, d) { return s + d.cost; }, 0);
            ex.dqDrivers.forEach(function(d) {
                var col = d.tier === 'strong' || d.tier === 'good' ? '#0a8f3e' : d.tier === 'limited' ? '#0288d1' : d.tier === 'sparse' ? '#f57c00' : '#c62828';
                var costPct = dqTotal > 0 ? ((d.cost / dqTotal) * 100).toFixed(0) : 0;
                h += '<br>' + drvTag('n=' + d.n, col) + ' ' + d.name + ' ‚Äî ' + d.tier + ' (' + costPct + '% of cost)';
            });
        }
        h += '</div>';

        h += '<div style="font-weight:700;font-size:12px;margin-top:6px;">Composite: ' + (conf.composite * 100).toFixed(0) + '% ‚Äî ' + conf.descriptor + '</div>';
    }

    // Unit Cost Check
    if (snap.unitChecks.length > 0) {
        h += '<h2>Unit Cost Reasonableness Check</h2>';
        h += '<table><thead><tr><th>Activity</th><th class="right">Qty</th><th>Unit</th><th class="right">Calc $/Unit</th><th class="right">P25</th><th class="right">Med</th><th class="right">P75</th><th>Status</th></tr></thead><tbody>';
        snap.unitChecks.forEach(c => {
            const badgeClass = c.status.replace(/\s+/g, '-').toLowerCase();
            h += '<tr><td>' + c.name + (c.clustered ? ' ‚ö°' : '') + '</td><td class="right">' + c.qty.toLocaleString() + '</td><td>' + c.unit + '</td><td class="right mono">$' + c.unitCost.toFixed(2) + '</td><td class="right mono">$' + c.p25.toFixed(2) + '</td><td class="right mono">$' + c.med.toFixed(2) + '</td><td class="right mono">$' + c.p75.toFixed(2) + '</td><td><span class="badge ' + badgeClass + '">' + c.status + '</span></td></tr>';
        });
        h += '</tbody></table>';
    }

    // Cost Summary
    h += '<h2>Cost Summary (Standard Tier)</h2>';
    h += '<div class="cost-grid">';
    // Labor column
    h += '<div><h3>Labor & Equipment</h3>';
    const laborKeys = ['cf','sc','st','ar','ma','ws','sg','bo','sb','sh','in','pr'];
    const laborNames = { cf:'Crack Filling', sc:'Seal Coating', st:'Striping', ar:'Asphalt Repairs', ma:'Mastic', ws:'Wheel Stops', sg:'Signs', bo:'Bollards', sb:'Speed Bumps', sh:'Speed Humps', 'in':'Inlet Repair', pr:'Paint Removal' };
    laborKeys.forEach(k => {
        const v = snap.summary.laborByType[k] || 0;
        if (v > 0) h += '<div class="cost-line"><span>' + laborNames[k] + '</span><span class="mono">$' + v.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div>';
    });
    h += '<div class="cost-line subtotal"><span>Subtotal</span><span class="mono">$' + snap.summary.totalLabor.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div></div>';
    // Material column
    h += '<div><h3>Materials</h3>';
    laborKeys.forEach(k => {
        const v = snap.summary.materialByType[k] || 0;
        if (v > 0) h += '<div class="cost-line"><span>' + laborNames[k] + '</span><span class="mono">$' + v.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div>';
    });
    h += '<div class="cost-line subtotal"><span>Subtotal</span><span class="mono">$' + snap.summary.totalMat.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div></div>';
    // Unit Cost column
    if (snap.unitChecks.length > 0) {
        h += '<div><h3>Unit Costs</h3>';
        snap.unitChecks.forEach(c => {
            const badgeClass = c.status.replace(/\s+/g, '-').toLowerCase();
            h += '<div class="cost-line"><span>' + c.name + '</span><span class="mono">$' + c.unitCost.toFixed(2) + '/' + c.unit + ' <span class="badge ' + badgeClass + '">' + c.status + '</span></span></div>';
        });
        h += '</div>';
    }
    h += '</div>';
    // Totals
    h += '<div class="totals">';
    h += '<div class="row"><span>Direct Cost</span><span class="mono">$' + snap.summary.directCost.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div>';
    h += '<div class="row"><span>Markup (' + snap.summary.markupPercent + '%)</span><span class="mono">$' + snap.summary.markupAmount.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div>';
    h += '<div class="row grand"><span>BID PRICE</span><span class="mono">$' + snap.summary.bidPrice.toLocaleString(undefined, {minimumFractionDigits:2, maximumFractionDigits:2}) + '</span></div>';
    h += '</div>';

    // Job Analysis
    if (analysis.length > 0) {
        h += '<h2>Job Analysis</h2>';
        analysis.forEach(obs => {
            const cls = obs.flag === 'üî¥' || obs.flag === '‚ö†' ? 'high' : 'low';
            h += '<div class="obs ' + cls + '"><strong>' + obs.flag + ' ' + obs.activity;
            if (obs.unitCost !== undefined) h += ' ‚Äî $' + obs.unitCost.toFixed(2) + '/' + obs.unit;
            h += '</strong>';
            obs.reasons.forEach(r => { h += '<br>‚Ä¢ ' + r; });
            h += '</div>';
        });
    }

    // Scope Assumptions
    if (snap.scopeAssumptions) {
        const sa = snap.scopeAssumptions;
        if (sa.included.length > 0 || sa.excluded.length > 0) {
            h += '<h2>Scope Exclusions & Assumptions</h2>';
            if (sa.included.length > 0) {
                h += '<div class="scope-section"><h3>Included</h3>';
                sa.included.forEach(s => { h += '<div class="item"><span class="tag incl">INCL</span><span>' + s.name + (s.note ? ' ‚Äî ' + s.note : '') + '</span></div>'; });
                h += '</div>';
            }
            if (sa.excluded.length > 0) {
                h += '<div class="scope-section"><h3>Excluded</h3>';
                sa.excluded.forEach(s => { h += '<div class="item"><span class="tag excl">EXCL</span><span>' + s.name + (s.note ? ' ‚Äî ' + s.note : '') + '</span></div>'; });
                h += '</div>';
            }
            if (sa.na.length > 0) {
                h += '<div class="scope-section"><h3>N/A</h3>';
                sa.na.forEach(s => { h += '<div class="item"><span class="tag na">N/A</span><span>' + s.name + (s.note ? ' ‚Äî ' + s.note : '') + '</span></div>'; });
                h += '</div>';
            }
        }
    }

    // Reviewer Notes
    if (snap.notes && Object.keys(snap.notes).length > 0) {
        h += '<h2>Reviewer Notes</h2>';
        for (const [key, text] of Object.entries(snap.notes)) {
            h += '<div class="notes-block"><strong>' + (NOTE_LABELS[key] || key) + '</strong><br>' + text.replace(/\n/g, '<br>') + '</div>';
        }
    }

    // Footer
    h += '<div class="footer">Generated by Maintenance Division Estimating Calculator v' + snap.meta.version + ' | ' + new Date().toLocaleString() + '</div>';
    h += '</body></html>';

    // Open new window and trigger print
    const printWin = window.open('', '_blank');
    if (!printWin) { showToast('Pop-up blocked ‚Äî allow pop-ups for this page'); return; }
    printWin.document.write(h);
    printWin.document.close();
    setTimeout(() => { printWin.print(); }, 500);
    showToast('Print window opened!');
}

// ===== INIT =====
const CALC_VERSION = '4.1';
// v4.1: Crew size now affects pricing. Each crew rate is calibrated to a base crew size
//       (stored in BASE_CREW_SIZES constant). When the user changes crew size, delta members
//       are priced at the configurable Laborer Adjustment Rate (default $39.03/hr, AAS Paint
//       Labor fully loaded: $26.30 base + 14.19% tax + $8.99 fringe). Formula:
//       effectiveRate = baseRate + (currentCrew ‚àí baseCrew) √ó laborerRate.
//       Works for all 12 activities including wheel stops (3 differentiated rates) and
//       asphalt repair (auto crew selection by tonnage). Rate adjustment shown in output panels
//       when crew size differs from base. Persisted in localStorage via save/load.
//
// v4.0: Six feature additions aligned with AACE/ASPE/AIA estimating best practices:
//       1. Differentiated wheel stop production rates (install 80, reset 155, removal 220/day)
//          per field-calibrated Q21 data. Analysis engine compares user rates vs field benchmarks.
//       2. Scope Exclusions & Assumptions checklist (12 items, Incl/Excl/N/A radios + notes).
//          Persists in localStorage. Exported in all 3 formats. Per ASPE Standard Estimating Practice.
//       3. Risk-Weighted Estimate Confidence score (4 sub-scores: Production Reliability 35%,
//          Benchmark Alignment 30%, Scope Definition 20%, Data Quality 15%). Each component
//          includes explanatory drivers showing exactly why the score is what it is.
//       4. Per-activity unit cost column in Cost Summary with status badges.
//       5. Calendar Duration Estimate with work sequencing, cure windows between dependent
//          activities, and weather contingency input. Scans all prior clusters for cure dependencies.
//       6. Print/PDF export ‚Äî opens clean white-background document in new window with all sections.
//       Also: BENCHMARKS now include sample sizes (n=), RATE_CONFIDENCE moved to module scope,
//       unitChecks carry benchKey and totalCost for confidence scoring.
//
// v3.5: Sealcoat production rate recalibrated from 60,000 to 52,000 SF/day based on superintendent
//       field data (Darrell Bishop, Feb 2026). 3-man baseline: 45K normal, 50K strong, 55K elite.
//       4th man required for manual spray bar. Added crew clustering engine: activities sharing
//       equipment cluster (heavy, paint, sealcoat, crack fill, mastic) share one mobilization.
//       Shift optimizer runs per cluster, not per activity. Hours apportioned back to activities
//       for HeavyBid entry. Cluster deployment summary added to estimate output and exports.

document.addEventListener('DOMContentLoaded', function() {
    renderScopeChecklist();
    const saved = localStorage.getItem('maintCalcRates');
    if (saved) {
        const data = JSON.parse(saved);
        if (data._version !== CALC_VERSION) {
            localStorage.removeItem('maintCalcRates');
            showToast('Rates reset to v' + CALC_VERSION + ' defaults (previous version cleared)');
        } else {
            Object.keys(data).forEach(key => {
                if (key === '_version') return;
                // Scope radio states
                if (key.startsWith('scope_') && !key.startsWith('scope_note_')) {
                    const radio = document.getElementById(key + '_' + data[key]);
                    if (radio) radio.checked = true;
                    return;
                }
                // Scope notes
                if (key.startsWith('scope_note_')) {
                    const el = document.getElementById(key);
                    if (el) el.value = data[key];
                    return;
                }
                const el = document.getElementById(key);
                if (el) el.value = data[key];
            });
            // Update sealcoat method note to match loaded selection
            const scNote = document.getElementById('sc_methodNote');
            const scCfg = SEALCOAT_METHODS[document.getElementById('sc_method').value];
            if (scNote && scCfg) scNote.textContent = scCfg.note;
        }
    }

    // Add asphalt price warning div if not present
    if (!document.getElementById('asphaltWarning')) {
        const settingsPanel = document.querySelector('.settings-panel');
        if (settingsPanel) {
            const warn = document.createElement('div');
            warn.id = 'asphaltWarning';
            warn.style.cssText = 'display:none; background:#442200; border:1px solid #ff8800; color:#ffcc00; padding:0.5rem 0.75rem; border-radius:6px; font-size:0.75rem; margin-top:0.5rem;';
            warn.innerHTML = '&#9888; Asphalt quantities entered but asphalt prices are empty. Material costs will be $0.';
            settingsPanel.appendChild(warn);
        }
    }

    calculateAll();
});
</script>
</body>
</html>
